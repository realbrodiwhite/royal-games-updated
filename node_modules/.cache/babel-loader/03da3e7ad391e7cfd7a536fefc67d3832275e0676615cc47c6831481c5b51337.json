{"ast":null,"code":"import { ObservablePoint } from '../../maths/point/ObservablePoint.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { ViewContainer } from '../view/View.mjs';\n\"use strict\";\nclass AbstractText extends ViewContainer {\n  constructor(options, styleClass) {\n    const {\n      text,\n      resolution,\n      style,\n      anchor,\n      width,\n      height,\n      roundPixels,\n      ...rest\n    } = options;\n    super({\n      ...rest\n    });\n    this.batched = true;\n    this._resolution = null;\n    this._autoResolution = true;\n    this._didTextUpdate = true;\n    this._styleClass = styleClass;\n    this.text = text ?? \"\";\n    this.style = style;\n    this.resolution = resolution ?? null;\n    this.allowChildren = false;\n    this._anchor = new ObservablePoint({\n      _onUpdate: () => {\n        this.onViewUpdate();\n      }\n    });\n    if (anchor) this.anchor = anchor;\n    this.roundPixels = roundPixels ?? false;\n    if (width !== void 0) this.width = width;\n    if (height !== void 0) this.height = height;\n  }\n  /**\n   * The anchor sets the origin point of the text.\n   * The default is `(0,0)`, this means the text's origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { Text } from 'pixi.js';\n   *\n   * const text = new Text('hello world');\n   * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /** Set the copy for the text object. To split a line you can use '\\n'. */\n  set text(value) {\n    value = value.toString();\n    if (this._text === value) return;\n    this._text = value;\n    this.onViewUpdate();\n  }\n  get text() {\n    return this._text;\n  }\n  /**\n   * The resolution / device pixel ratio of the canvas.\n   * @default 1\n   */\n  set resolution(value) {\n    this._autoResolution = value === null;\n    this._resolution = value;\n    this.onViewUpdate();\n  }\n  get resolution() {\n    return this._resolution;\n  }\n  get style() {\n    return this._style;\n  }\n  /**\n   * Set the style of the text.\n   *\n   * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n   *\n   * If setting the `style` can also be partial {@link AnyTextStyleOptions}.\n   * @type {\n   * text.TextStyle |\n   * Partial<text.TextStyle> |\n   * text.TextStyleOptions |\n   * text.HTMLTextStyle |\n   * Partial<text.HTMLTextStyle> |\n   * text.HTMLTextStyleOptions\n   * }\n   */\n  set style(style) {\n    style = style || {};\n    this._style?.off(\"update\", this.onViewUpdate, this);\n    if (style instanceof this._styleClass) {\n      this._style = style;\n    } else {\n      this._style = new this._styleClass(style);\n    }\n    this._style.on(\"update\", this.onViewUpdate, this);\n    this.onViewUpdate();\n  }\n  /**\n   * The local bounds of the Text.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    if (this._boundsDirty) {\n      this._updateBounds();\n      this._boundsDirty = false;\n    }\n    return this._bounds;\n  }\n  /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get width() {\n    return Math.abs(this.scale.x) * this.bounds.width;\n  }\n  set width(value) {\n    this._setWidth(value, this.bounds.width);\n  }\n  /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n  get height() {\n    return Math.abs(this.scale.y) * this.bounds.height;\n  }\n  set height(value) {\n    this._setHeight(value, this.bounds.height);\n  }\n  /**\n   * Retrieves the size of the Text as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the Text.\n   */\n  getSize(out) {\n    out || (out = {});\n    out.width = Math.abs(this.scale.x) * this.bounds.width;\n    out.height = Math.abs(this.scale.y) * this.bounds.height;\n    return out;\n  }\n  /**\n   * Sets the size of the Text to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */\n  setSize(value, height) {\n    if (typeof value === \"object\") {\n      height = value.height ?? value.width;\n      value = value.width;\n    } else {\n      height ?? (height = value);\n    }\n    value !== void 0 && this._setWidth(value, this.bounds.width);\n    height !== void 0 && this._setHeight(height, this.bounds.height);\n  }\n  /**\n   * Adds the bounds of this text to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    const _bounds = this.bounds;\n    bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n  }\n  /**\n   * Checks if the text contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const width = this.bounds.width;\n    const height = this.bounds.height;\n    const x1 = -width * this.anchor.x;\n    let y1 = 0;\n    if (point.x >= x1 && point.x <= x1 + width) {\n      y1 = -height * this.anchor.y;\n      if (point.y >= y1 && point.y <= y1 + height) return true;\n    }\n    return false;\n  }\n  onViewUpdate() {\n    this._didViewChangeTick++;\n    this._boundsDirty = true;\n    if (this.didViewUpdate) return;\n    this.didViewUpdate = true;\n    this._didTextUpdate = true;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.onChildViewUpdate(this);\n    }\n  }\n  _getKey() {\n    return `${this.text}:${this._style.styleKey}:${this._resolution}`;\n  }\n  /**\n   * Destroys this text renderable and optionally its style texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style\n   * @param {boolean} [options.style=false] - Should it destroy the style of the text\n   */\n  destroy() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    super.destroy(options);\n    this.owner = null;\n    this._bounds = null;\n    this._anchor = null;\n    if (typeof options === \"boolean\" ? options : options?.style) {\n      this._style.destroy(options);\n    }\n    this._style = null;\n    this._text = null;\n  }\n}\nfunction ensureOptions(args, name) {\n  let options = args[0] ?? {};\n  if (typeof options === \"string\" || args[1]) {\n    deprecation(v8_0_0, `use new ${name}({ text: \"hi!\", style }) instead`);\n    options = {\n      text: options,\n      style: args[1]\n    };\n  }\n  return options;\n}\nexport { AbstractText, ensureOptions };","map":{"version":3,"names":["AbstractText","ViewContainer","constructor","options","styleClass","text","resolution","style","anchor","width","height","roundPixels","rest","batched","_resolution","_autoResolution","_didTextUpdate","_styleClass","allowChildren","_anchor","ObservablePoint","_onUpdate","onViewUpdate","value","set","copyFrom","toString","_text","_style","off","on","bounds","_boundsDirty","_updateBounds","_bounds","Math","abs","scale","x","_setWidth","y","_setHeight","getSize","out","setSize","addBounds","addFrame","minX","minY","maxX","maxY","containsPoint","point","x1","y1","_didViewChangeTick","didViewUpdate","renderGroup","parentRenderGroup","onChildViewUpdate","_getKey","styleKey","destroy","arguments","length","undefined","owner","ensureOptions","args","name","deprecation","v8_0_0"],"sources":["/workspaces/royal-games-updated/node_modules/pixi.js/src/scene/text/AbstractText.ts"],"sourcesContent":["import { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { ViewContainer } from '../view/View';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { Bounds } from '../container/bounds/Bounds';\nimport type { ContainerOptions } from '../container/Container';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\nimport type { HTMLTextStyle, HTMLTextStyleOptions } from '../text-html/HtmlTextStyle';\nimport type { TextStyle, TextStyleOptions } from './TextStyle';\n\n/**\n * A string or number that can be used as text.\n * @memberof text\n */\nexport type TextString = string | number | { toString: () => string };\n/**\n * A union of all text styles, including HTML, Bitmap and Canvas text styles.\n * @memberof text\n * @see text.TextStyle\n * @see text.HTMLTextStyle\n */\nexport type AnyTextStyle = TextStyle | HTMLTextStyle;\n/**\n * A union of all text style options, including HTML, Bitmap and Canvas text style options.\n * @memberof text\n * @see text.TextStyleOptions\n * @see text.HTMLTextStyleOptions\n */\nexport type AnyTextStyleOptions = TextStyleOptions | HTMLTextStyleOptions;\n\n/**\n * Options for the {@link scene.Text} class.\n * @example\n * const text = new Text({\n *    text: 'Hello Pixi!',\n *    style: {\n *       fontFamily: 'Arial',\n *       fontSize: 24,\n *    fill: 0xff1010,\n *    align: 'center',\n *  }\n * });\n * @memberof text\n */\nexport interface TextOptions<\n    TEXT_STYLE extends TextStyle = TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions = TextStyleOptions,\n> extends ContainerOptions\n{\n    /** The anchor point of the text. */\n    anchor?: PointData | number;\n    /** The copy for the text object. To split a line you can use '\\n'. */\n    text?: TextString;\n    /** The resolution of the text. */\n    resolution?: number;\n    /**\n     * The text style\n     * @type {\n     * text.TextStyle |\n     * Partial<text.TextStyle> |\n     * text.TextStyleOptions |\n     * text.HTMLTextStyle |\n     * Partial<text.HTMLTextStyle> |\n     * text.HTMLTextStyleOptions\n     * }\n     */\n    style?: TEXT_STYLE | TEXT_STYLE_OPTIONS;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * An abstract Text class, used by all text type in Pixi. This includes Canvas, HTML, and Bitmap Text.\n * @see scene.Text\n * @see scene.BitmapText\n * @see scene.HTMLText\n * @memberof scene\n */\nexport abstract class AbstractText<\n    TEXT_STYLE extends TextStyle = TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions = TextStyleOptions,\n> extends ViewContainer implements View\n{\n    public batched = true;\n    public _anchor: ObservablePoint;\n\n    public _resolution: number = null;\n    public _autoResolution: boolean = true;\n\n    public _style: TEXT_STYLE;\n    public _didTextUpdate = true;\n\n    protected _text: string;\n    private readonly _styleClass: new (options: TEXT_STYLE_OPTIONS) => TEXT_STYLE;\n\n    constructor(\n        options: TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>,\n        styleClass: new (options: TEXT_STYLE_OPTIONS) => TEXT_STYLE\n    )\n    {\n        const { text, resolution, style, anchor, width, height, roundPixels, ...rest } = options;\n\n        super({\n            ...rest\n        });\n\n        this._styleClass = styleClass;\n\n        this.text = text ?? '';\n\n        this.style = style;\n\n        this.resolution = resolution ?? null;\n\n        this.allowChildren = false;\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                },\n            },\n        );\n\n        if (anchor) this.anchor = anchor;\n        this.roundPixels = roundPixels ?? false;\n\n        // needs to be set after the container has initiated\n        if (width !== undefined) this.width = width;\n        if (height !== undefined) this.height = height;\n    }\n\n    /**\n     * The anchor sets the origin point of the text.\n     * The default is `(0,0)`, this means the text's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * import { Text } from 'pixi.js';\n     *\n     * const text = new Text('hello world');\n     * text.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /** Set the copy for the text object. To split a line you can use '\\n'. */\n    set text(value: TextString)\n    {\n        // check its a string\n        value = value.toString();\n\n        if (this._text === value) return;\n\n        this._text = value as string;\n        this.onViewUpdate();\n    }\n\n    get text(): string\n    {\n        return this._text;\n    }\n\n    /**\n     * The resolution / device pixel ratio of the canvas.\n     * @default 1\n     */\n    set resolution(value: number)\n    {\n        this._autoResolution = value === null;\n        this._resolution = value;\n        this.onViewUpdate();\n    }\n\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    get style(): TEXT_STYLE\n    {\n        return this._style;\n    }\n\n    /**\n     * Set the style of the text.\n     *\n     * Set up an event listener to listen for changes on the style object and mark the text as dirty.\n     *\n     * If setting the `style` can also be partial {@link AnyTextStyleOptions}.\n     * @type {\n     * text.TextStyle |\n     * Partial<text.TextStyle> |\n     * text.TextStyleOptions |\n     * text.HTMLTextStyle |\n     * Partial<text.HTMLTextStyle> |\n     * text.HTMLTextStyleOptions\n     * }\n     */\n    set style(style: TEXT_STYLE | Partial<TEXT_STYLE> | TEXT_STYLE_OPTIONS)\n    {\n        style = style || {};\n\n        this._style?.off('update', this.onViewUpdate, this);\n\n        if (style instanceof this._styleClass)\n        {\n            this._style = style as TEXT_STYLE;\n        }\n        else\n        {\n            this._style = new this._styleClass(style as TEXT_STYLE_OPTIONS);\n        }\n\n        this._style.on('update', this.onViewUpdate, this);\n        this.onViewUpdate();\n    }\n\n    /**\n     * The local bounds of the Text.\n     * @type {rendering.Bounds}\n     */\n    get bounds()\n    {\n        if (this._boundsDirty)\n        {\n            this._updateBounds();\n            this._boundsDirty = false;\n        }\n\n        return this._bounds;\n    }\n\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get width(): number\n    {\n        return Math.abs(this.scale.x) * this.bounds.width;\n    }\n\n    override set width(value: number)\n    {\n        this._setWidth(value, this.bounds.width);\n    }\n\n    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get height(): number\n    {\n        return Math.abs(this.scale.y) * this.bounds.height;\n    }\n\n    override set height(value: number)\n    {\n        this._setHeight(value, this.bounds.height);\n    }\n\n    /**\n     * Retrieves the size of the Text as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the Text.\n     */\n    public override getSize(out?: Size): Size\n    {\n        out ||= {} as Size;\n        out.width = Math.abs(this.scale.x) * this.bounds.width;\n        out.height = Math.abs(this.scale.y) * this.bounds.height;\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the Text to the specified width and height.\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n        else\n        {\n            height ??= value;\n        }\n\n        value !== undefined && this._setWidth(value, this.bounds.width);\n        height !== undefined && this._setHeight(height, this.bounds.height);\n    }\n\n    /**\n     * Adds the bounds of this text to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        const _bounds = this.bounds;\n\n        bounds.addFrame(\n            _bounds.minX,\n            _bounds.minY,\n            _bounds.maxX,\n            _bounds.maxY,\n        );\n    }\n\n    /**\n     * Checks if the text contains the given point.\n     * @param point - The point to check\n     */\n    public override containsPoint(point: PointData)\n    {\n        const width = this.bounds.width;\n        const height = this.bounds.height;\n\n        const x1 = -width * this.anchor.x;\n        let y1 = 0;\n\n        if (point.x >= x1 && point.x <= x1 + width)\n        {\n            y1 = -height * this.anchor.y;\n\n            if (point.y >= y1 && point.y <= y1 + height) return true;\n        }\n\n        return false;\n    }\n\n    public onViewUpdate()\n    {\n        this._didViewChangeTick++;\n\n        this._boundsDirty = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        this._didTextUpdate = true;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    public _getKey(): string\n    {\n        return `${this.text}:${this._style.styleKey}:${this._resolution}`;\n    }\n\n    protected abstract _updateBounds(): void;\n\n    /**\n     * Destroys this text renderable and optionally its style texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the texture of the text style\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the text style\n     * @param {boolean} [options.style=false] - Should it destroy the style of the text\n     */\n    public override destroy(options: DestroyOptions = false): void\n    {\n        super.destroy(options);\n\n        (this as any).owner = null;\n        this._bounds = null;\n        this._anchor = null;\n\n        if (typeof options === 'boolean' ? options : options?.style)\n        {\n            this._style.destroy(options);\n        }\n\n        this._style = null;\n        this._text = null;\n    }\n}\n\nexport function ensureOptions<\n    TEXT_STYLE extends TextStyle,\n    TEXT_STYLE_OPTIONS extends TextStyleOptions\n>(\n    args: any[],\n    name: string\n): TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>\n{\n    let options = (args[0] ?? {}) as TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>;\n\n    // @deprecated\n    if (typeof options === 'string' || args[1])\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, `use new ${name}({ text: \"hi!\", style }) instead`);\n        // #endif\n\n        options = {\n            text: options,\n            style: args[1],\n        } as TextOptions<TEXT_STYLE, TEXT_STYLE_OPTIONS>;\n    }\n\n    return options;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}