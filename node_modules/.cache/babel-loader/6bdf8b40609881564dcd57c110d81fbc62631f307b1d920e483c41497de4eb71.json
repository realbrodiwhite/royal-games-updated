{"ast":null,"code":"import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { BatchableSprite } from '../sprite/BatchableSprite.mjs';\n\"use strict\";\nclass HTMLTextPipe {\n  constructor(renderer) {\n    this._gpuText = /* @__PURE__ */Object.create(null);\n    this._destroyRenderableBound = this.destroyRenderable.bind(this);\n    this._renderer = renderer;\n    this._renderer.runners.resolutionChange.add(this);\n  }\n  resolutionChange() {\n    for (const i in this._gpuText) {\n      const gpuText = this._gpuText[i];\n      if (!gpuText) continue;\n      const text = gpuText.batchableSprite.renderable;\n      if (text._autoResolution) {\n        text._resolution = this._renderer.resolution;\n        text.onViewUpdate();\n      }\n    }\n  }\n  validateRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const newKey = htmlText._getKey();\n    if (gpuText.textureNeedsUploading) {\n      gpuText.textureNeedsUploading = false;\n      return true;\n    }\n    if (gpuText.currentKey !== newKey) {\n      return true;\n    }\n    return false;\n  }\n  addRenderable(htmlText, instructionSet) {\n    const gpuText = this._getGpuText(htmlText);\n    const batchableSprite = gpuText.batchableSprite;\n    if (htmlText._didTextUpdate) {\n      this._updateText(htmlText);\n    }\n    this._renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);\n  }\n  updateRenderable(htmlText) {\n    const gpuText = this._getGpuText(htmlText);\n    const batchableSprite = gpuText.batchableSprite;\n    if (htmlText._didTextUpdate) {\n      this._updateText(htmlText);\n    }\n    batchableSprite._batcher.updateElement(batchableSprite);\n  }\n  destroyRenderable(htmlText) {\n    htmlText.off(\"destroyed\", this._destroyRenderableBound);\n    this._destroyRenderableById(htmlText.uid);\n  }\n  _destroyRenderableById(htmlTextUid) {\n    const gpuText = this._gpuText[htmlTextUid];\n    this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n    BigPool.return(gpuText.batchableSprite);\n    this._gpuText[htmlTextUid] = null;\n  }\n  _updateText(htmlText) {\n    const newKey = htmlText._getKey();\n    const gpuText = this._getGpuText(htmlText);\n    const batchableSprite = gpuText.batchableSprite;\n    if (gpuText.currentKey !== newKey) {\n      this._updateGpuText(htmlText).catch(e => {\n        console.error(e);\n      });\n    }\n    htmlText._didTextUpdate = false;\n    const padding = htmlText._style.padding;\n    updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n  }\n  async _updateGpuText(htmlText) {\n    htmlText._didTextUpdate = false;\n    const gpuText = this._getGpuText(htmlText);\n    if (gpuText.generatingTexture) return;\n    const newKey = htmlText._getKey();\n    this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n    gpuText.generatingTexture = true;\n    gpuText.currentKey = newKey;\n    const resolution = htmlText.resolution ?? this._renderer.resolution;\n    const texture = await this._renderer.htmlText.getManagedTexture(htmlText.text, resolution, htmlText._style, htmlText._getKey());\n    const batchableSprite = gpuText.batchableSprite;\n    batchableSprite.texture = gpuText.texture = texture;\n    gpuText.generatingTexture = false;\n    gpuText.textureNeedsUploading = true;\n    htmlText.onViewUpdate();\n    const padding = htmlText._style.padding;\n    updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n  }\n  _getGpuText(htmlText) {\n    return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);\n  }\n  initGpuText(htmlText) {\n    const gpuTextData = {\n      texture: Texture.EMPTY,\n      currentKey: \"--\",\n      batchableSprite: BigPool.get(BatchableSprite),\n      textureNeedsUploading: false,\n      generatingTexture: false\n    };\n    const batchableSprite = gpuTextData.batchableSprite;\n    batchableSprite.renderable = htmlText;\n    batchableSprite.transform = htmlText.groupTransform;\n    batchableSprite.texture = Texture.EMPTY;\n    batchableSprite.bounds = {\n      minX: 0,\n      maxX: 1,\n      minY: 0,\n      maxY: 0\n    };\n    batchableSprite.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;\n    htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n    this._gpuText[htmlText.uid] = gpuTextData;\n    htmlText.on(\"destroyed\", this._destroyRenderableBound);\n    return gpuTextData;\n  }\n  destroy() {\n    for (const i in this._gpuText) {\n      this._destroyRenderableById(i);\n    }\n    this._gpuText = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nHTMLTextPipe.extension = {\n  type: [ExtensionType.WebGLPipes, ExtensionType.WebGPUPipes, ExtensionType.CanvasPipes],\n  name: \"htmlText\"\n};\nexport { HTMLTextPipe };","map":{"version":3,"names":["HTMLTextPipe","constructor","renderer","_gpuText","Object","create","_destroyRenderableBound","destroyRenderable","bind","_renderer","runners","resolutionChange","add","i","gpuText","text","batchableSprite","renderable","_autoResolution","_resolution","resolution","onViewUpdate","validateRenderable","htmlText","_getGpuText","newKey","_getKey","textureNeedsUploading","currentKey","addRenderable","instructionSet","_didTextUpdate","_updateText","renderPipes","batch","addToBatch","updateRenderable","_batcher","updateElement","off","_destroyRenderableById","uid","htmlTextUid","decreaseReferenceCount","BigPool","return","_updateGpuText","catch","e","console","error","padding","_style","updateQuadBounds","bounds","_anchor","texture","generatingTexture","getManagedTexture","initGpuText","gpuTextData","Texture","EMPTY","get","BatchableSprite","transform","groupTransform","minX","maxX","minY","maxY","roundPixels","_roundPixels","on","destroy","extension","type","ExtensionType","WebGLPipes","WebGPUPipes","CanvasPipes","name"],"sources":["/workspaces/royal-games-updated/node_modules/pixi.js/src/scene/text-html/HTMLTextPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../extensions/Extensions';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { Container } from '../container/Container';\nimport type { HTMLText } from './HTMLText';\nimport type { HTMLTextStyle } from './HtmlTextStyle';\n\nexport class HTMLTextPipe implements RenderPipe<HTMLText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        textureNeedsUploading: boolean;\n        generatingTexture: boolean;\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.runners.resolutionChange.add(this);\n    }\n\n    public resolutionChange()\n    {\n        for (const i in this._gpuText)\n        {\n            const gpuText = this._gpuText[i];\n\n            if (!gpuText) continue;\n\n            const text = gpuText.batchableSprite.renderable as HTMLText;\n\n            if (text._autoResolution)\n            {\n                text._resolution = this._renderer.resolution;\n                text.onViewUpdate();\n            }\n        }\n    }\n\n    public validateRenderable(htmlText: HTMLText): boolean\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const newKey = htmlText._getKey();\n\n        if (gpuText.textureNeedsUploading)\n        {\n            gpuText.textureNeedsUploading = false;\n\n            return true;\n        }\n\n        if (gpuText.currentKey !== newKey)\n        {\n            // TODO - could look into optimising this a tad!\n            // if its a single texture, then we could just swap it?\n            // same for CanvasText..\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(htmlText: HTMLText, instructionSet: InstructionSet)\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);\n    }\n\n    public updateRenderable(htmlText: HTMLText)\n    {\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        batchableSprite._batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(htmlText: HTMLText)\n    {\n        htmlText.off('destroyed', this._destroyRenderableBound);\n        this._destroyRenderableById(htmlText.uid);\n    }\n\n    private _destroyRenderableById(htmlTextUid: number)\n    {\n        const gpuText = this._gpuText[htmlTextUid];\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[htmlTextUid] = null;\n    }\n\n    private _updateText(htmlText: HTMLText)\n    {\n        const newKey = htmlText._getKey();\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(htmlText).catch((e) =>\n            {\n                console.error(e);\n            });\n        }\n\n        htmlText._didTextUpdate = false;\n\n        const padding = htmlText._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n\n    private async _updateGpuText(htmlText: HTMLText)\n    {\n        htmlText._didTextUpdate = false;\n\n        const gpuText = this._getGpuText(htmlText);\n\n        if (gpuText.generatingTexture) return;\n\n        const newKey = htmlText._getKey();\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        gpuText.generatingTexture = true;\n\n        gpuText.currentKey = newKey;\n\n        const resolution = htmlText.resolution ?? this._renderer.resolution;\n\n        const texture = await this._renderer.htmlText.getManagedTexture(\n            htmlText.text,\n            resolution,\n            htmlText._style as HTMLTextStyle,\n            htmlText._getKey()\n        );\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        batchableSprite.texture = gpuText.texture = texture;\n\n        gpuText.generatingTexture = false;\n\n        gpuText.textureNeedsUploading = true;\n        htmlText.onViewUpdate();\n\n        const padding = htmlText._style.padding;\n\n        updateQuadBounds(batchableSprite.bounds, htmlText._anchor, batchableSprite.texture, padding);\n    }\n\n    private _getGpuText(htmlText: HTMLText)\n    {\n        return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);\n    }\n\n    public initGpuText(htmlText: HTMLText)\n    {\n        const gpuTextData: HTMLTextPipe['_gpuText'][number] = {\n            texture: Texture.EMPTY,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n            textureNeedsUploading: false,\n            generatingTexture: false,\n        };\n\n        const batchableSprite = gpuTextData.batchableSprite;\n\n        batchableSprite.renderable = htmlText;\n        batchableSprite.transform = htmlText.groupTransform;\n        batchableSprite.texture = Texture.EMPTY;\n        batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableSprite.roundPixels = (this._renderer._roundPixels | htmlText._roundPixels) as 0 | 1;\n\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n        this._gpuText[htmlText.uid] = gpuTextData;\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        htmlText.on('destroyed', this._destroyRenderableBound);\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}