{"ast":null,"code":"import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\nimport { ensureAttributes } from '../../gl/shader/program/ensureAttributes.mjs';\nimport { STENCIL_MODES } from '../../shared/state/const.mjs';\nimport { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { GpuStencilModesToPixi } from '../state/GpuStencilModesToPixi.mjs';\n\"use strict\";\nconst topologyStringToId = {\n  \"point-list\": 0,\n  \"line-list\": 1,\n  \"line-strip\": 2,\n  \"triangle-list\": 3,\n  \"triangle-strip\": 4\n};\nfunction getGraphicsStateKey(geometryLayout, shaderKey, state, blendMode, topology) {\n  return geometryLayout << 24 | shaderKey << 16 | state << 10 | blendMode << 5 | topology;\n}\nfunction getGlobalStateKey(stencilStateId, multiSampleCount, colorMask, renderTarget) {\n  return colorMask << 6 | stencilStateId << 3 | renderTarget << 1 | multiSampleCount;\n}\nclass PipelineSystem {\n  constructor(renderer) {\n    this._moduleCache = /* @__PURE__ */Object.create(null);\n    this._bufferLayoutsCache = /* @__PURE__ */Object.create(null);\n    this._bindingNamesCache = /* @__PURE__ */Object.create(null);\n    this._pipeCache = /* @__PURE__ */Object.create(null);\n    this._pipeStateCaches = /* @__PURE__ */Object.create(null);\n    this._colorMask = 15;\n    this._multisampleCount = 1;\n    this._renderer = renderer;\n  }\n  contextChange(gpu) {\n    this._gpu = gpu;\n    this.setStencilMode(STENCIL_MODES.DISABLED);\n    this._updatePipeHash();\n  }\n  setMultisampleCount(multisampleCount) {\n    if (this._multisampleCount === multisampleCount) return;\n    this._multisampleCount = multisampleCount;\n    this._updatePipeHash();\n  }\n  setRenderTarget(renderTarget) {\n    this._multisampleCount = renderTarget.msaaSamples;\n    this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;\n    this._updatePipeHash();\n  }\n  setColorMask(colorMask) {\n    if (this._colorMask === colorMask) return;\n    this._colorMask = colorMask;\n    this._updatePipeHash();\n  }\n  setStencilMode(stencilMode) {\n    if (this._stencilMode === stencilMode) return;\n    this._stencilMode = stencilMode;\n    this._stencilState = GpuStencilModesToPixi[stencilMode];\n    this._updatePipeHash();\n  }\n  setPipeline(geometry, program, state, passEncoder) {\n    const pipeline = this.getPipeline(geometry, program, state);\n    passEncoder.setPipeline(pipeline);\n  }\n  getPipeline(geometry, program, state, topology) {\n    if (!geometry._layoutKey) {\n      ensureAttributes(geometry, program.attributeData);\n      this._generateBufferKey(geometry);\n    }\n    topology = topology || geometry.topology;\n    const key = getGraphicsStateKey(geometry._layoutKey, program._layoutKey, state.data, state._blendModeId, topologyStringToId[topology]);\n    if (this._pipeCache[key]) return this._pipeCache[key];\n    this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);\n    return this._pipeCache[key];\n  }\n  _createPipeline(geometry, program, state, topology) {\n    const device = this._gpu.device;\n    const buffers = this._createVertexBufferLayouts(geometry, program);\n    const blendModes = this._renderer.state.getColorTargets(state);\n    blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;\n    const layout = this._renderer.shader.getProgramData(program).pipeline;\n    const descriptor = {\n      // TODO later check if its helpful to create..\n      // layout,\n      vertex: {\n        module: this._getModule(program.vertex.source),\n        entryPoint: program.vertex.entryPoint,\n        // geometry..\n        buffers\n      },\n      fragment: {\n        module: this._getModule(program.fragment.source),\n        entryPoint: program.fragment.entryPoint,\n        targets: blendModes\n      },\n      primitive: {\n        topology,\n        cullMode: state.cullMode\n      },\n      layout,\n      multisample: {\n        count: this._multisampleCount\n      },\n      // depthStencil,\n      label: `PIXI Pipeline`\n    };\n    if (this._depthStencilAttachment) {\n      descriptor.depthStencil = {\n        ...this._stencilState,\n        format: \"depth24plus-stencil8\",\n        depthWriteEnabled: state.depthTest,\n        depthCompare: state.depthTest ? \"less\" : \"always\"\n      };\n    }\n    const pipeline = device.createRenderPipeline(descriptor);\n    return pipeline;\n  }\n  _getModule(code) {\n    return this._moduleCache[code] || this._createModule(code);\n  }\n  _createModule(code) {\n    const device = this._gpu.device;\n    this._moduleCache[code] = device.createShaderModule({\n      code\n    });\n    return this._moduleCache[code];\n  }\n  _generateBufferKey(geometry) {\n    const keyGen = [];\n    let index = 0;\n    const attributeKeys = Object.keys(geometry.attributes).sort();\n    for (let i = 0; i < attributeKeys.length; i++) {\n      const attribute = geometry.attributes[attributeKeys[i]];\n      keyGen[index++] = attribute.offset;\n      keyGen[index++] = attribute.format;\n      keyGen[index++] = attribute.stride;\n      keyGen[index++] = attribute.instance;\n    }\n    const stringKey = keyGen.join(\"|\");\n    geometry._layoutKey = createIdFromString(stringKey, \"geometry\");\n    return geometry._layoutKey;\n  }\n  _generateAttributeLocationsKey(program) {\n    const keyGen = [];\n    let index = 0;\n    const attributeKeys = Object.keys(program.attributeData).sort();\n    for (let i = 0; i < attributeKeys.length; i++) {\n      const attribute = program.attributeData[attributeKeys[i]];\n      keyGen[index++] = attribute.location;\n    }\n    const stringKey = keyGen.join(\"|\");\n    program._attributeLocationsKey = createIdFromString(stringKey, \"programAttributes\");\n    return program._attributeLocationsKey;\n  }\n  /**\n   * Returns a hash of buffer names mapped to bind locations.\n   * This is used to bind the correct buffer to the correct location in the shader.\n   * @param geometry - The geometry where to get the buffer names\n   * @param program - The program where to get the buffer names\n   * @returns An object of buffer names mapped to the bind location.\n   */\n  getBufferNamesToBind(geometry, program) {\n    const key = geometry._layoutKey << 16 | program._attributeLocationsKey;\n    if (this._bindingNamesCache[key]) return this._bindingNamesCache[key];\n    const data = this._createVertexBufferLayouts(geometry, program);\n    const bufferNamesToBind = /* @__PURE__ */Object.create(null);\n    const attributeData = program.attributeData;\n    for (let i = 0; i < data.length; i++) {\n      for (const j in attributeData) {\n        if (attributeData[j].location === i) {\n          bufferNamesToBind[i] = j;\n          break;\n        }\n      }\n    }\n    this._bindingNamesCache[key] = bufferNamesToBind;\n    return bufferNamesToBind;\n  }\n  _createVertexBufferLayouts(geometry, program) {\n    if (!program._attributeLocationsKey) this._generateAttributeLocationsKey(program);\n    const key = geometry._layoutKey << 16 | program._attributeLocationsKey;\n    if (this._bufferLayoutsCache[key]) {\n      return this._bufferLayoutsCache[key];\n    }\n    const vertexBuffersLayout = [];\n    geometry.buffers.forEach(buffer => {\n      const bufferEntry = {\n        arrayStride: 0,\n        stepMode: \"vertex\",\n        attributes: []\n      };\n      const bufferEntryAttributes = bufferEntry.attributes;\n      for (const i in program.attributeData) {\n        const attribute = geometry.attributes[i];\n        if ((attribute.divisor ?? 1) !== 1) {\n          warn(`Attribute ${i} has an invalid divisor value of '${attribute.divisor}'. WebGPU only supports a divisor value of 1`);\n        }\n        if (attribute.buffer === buffer) {\n          bufferEntry.arrayStride = attribute.stride;\n          bufferEntry.stepMode = attribute.instance ? \"instance\" : \"vertex\";\n          bufferEntryAttributes.push({\n            shaderLocation: program.attributeData[i].location,\n            offset: attribute.offset,\n            format: attribute.format\n          });\n        }\n      }\n      if (bufferEntryAttributes.length) {\n        vertexBuffersLayout.push(bufferEntry);\n      }\n    });\n    this._bufferLayoutsCache[key] = vertexBuffersLayout;\n    return vertexBuffersLayout;\n  }\n  _updatePipeHash() {\n    const key = getGlobalStateKey(this._stencilMode, this._multisampleCount, this._colorMask, this._depthStencilAttachment);\n    if (!this._pipeStateCaches[key]) {\n      this._pipeStateCaches[key] = /* @__PURE__ */Object.create(null);\n    }\n    this._pipeCache = this._pipeStateCaches[key];\n  }\n  destroy() {\n    this._renderer = null;\n    this._bufferLayoutsCache = null;\n  }\n}\n/** @ignore */\nPipelineSystem.extension = {\n  type: [ExtensionType.WebGPUSystem],\n  name: \"pipeline\"\n};\nexport { PipelineSystem };","map":{"version":3,"names":["topologyStringToId","getGraphicsStateKey","geometryLayout","shaderKey","state","blendMode","topology","getGlobalStateKey","stencilStateId","multiSampleCount","colorMask","renderTarget","PipelineSystem","constructor","renderer","_moduleCache","Object","create","_bufferLayoutsCache","_bindingNamesCache","_pipeCache","_pipeStateCaches","_colorMask","_multisampleCount","_renderer","contextChange","gpu","_gpu","setStencilMode","STENCIL_MODES","DISABLED","_updatePipeHash","setMultisampleCount","multisampleCount","setRenderTarget","msaaSamples","_depthStencilAttachment","descriptor","depthStencilAttachment","setColorMask","stencilMode","_stencilMode","_stencilState","GpuStencilModesToPixi","setPipeline","geometry","program","passEncoder","pipeline","getPipeline","_layoutKey","ensureAttributes","attributeData","_generateBufferKey","key","data","_blendModeId","_createPipeline","device","buffers","_createVertexBufferLayouts","blendModes","getColorTargets","writeMask","RENDERING_MASK_ADD","layout","shader","getProgramData","vertex","module","_getModule","source","entryPoint","fragment","targets","primitive","cullMode","multisample","count","label","depthStencil","format","depthWriteEnabled","depthTest","depthCompare","createRenderPipeline","code","_createModule","createShaderModule","keyGen","index","attributeKeys","keys","attributes","sort","i","length","attribute","offset","stride","instance","stringKey","join","createIdFromString","_generateAttributeLocationsKey","location","_attributeLocationsKey","getBufferNamesToBind","bufferNamesToBind","j","vertexBuffersLayout","forEach","buffer","bufferEntry","arrayStride","stepMode","bufferEntryAttributes","divisor","warn","push","shaderLocation","destroy","extension","type","ExtensionType","WebGPUSystem","name"],"sources":["/workspaces/royal-games-updated/node_modules/pixi.js/src/rendering/renderers/gpu/pipeline/PipelineSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { warn } from '../../../../utils/logging/warn';\nimport { ensureAttributes } from '../../gl/shader/program/ensureAttributes';\nimport { STENCIL_MODES } from '../../shared/state/const';\nimport { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { GpuStencilModesToPixi } from '../state/GpuStencilModesToPixi';\n\nimport type { Topology } from '../../shared/geometry/const';\nimport type { Geometry } from '../../shared/geometry/Geometry';\nimport type { State } from '../../shared/state/State';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { GpuRenderTarget } from '../renderTarget/GpuRenderTarget';\nimport type { GpuProgram } from '../shader/GpuProgram';\nimport type { StencilState } from '../state/GpuStencilModesToPixi';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\nconst topologyStringToId = {\n    'point-list': 0,\n    'line-list': 1,\n    'line-strip': 2,\n    'triangle-list': 3,\n    'triangle-strip': 4,\n};\n\n// geometryLayouts = 256; // 8 bits // 256 states // value 0-255;\n// shaderKeys = 256; // 8 bits // 256 states // value 0-255;\n// state = 64; // 6 bits // 64 states // value 0-63;\n// blendMode = 32; // 5 bits // 32 states // value 0-31;\n// topology = 8; // 3 bits // 8 states // value 0-7;\nfunction getGraphicsStateKey(\n    geometryLayout: number,\n    shaderKey: number,\n    state: number,\n    blendMode: number,\n    topology: number,\n): number\n{\n    return (geometryLayout << 24) // Allocate the 8 bits for geometryLayouts at the top\n         | (shaderKey << 16) // Next 8 bits for shaderKeys\n         | (state << 10) // 6 bits for state\n         | (blendMode << 5) // 5 bits for blendMode\n         | topology; // And 3 bits for topology at the least significant position\n}\n\n// colorMask = 16;// 4 bits // 16 states // value 0-15;\n// stencilState = 8; // 3 bits // 8 states // value 0-7;\n// renderTarget = 1; // 2 bit // 3 states // value 0-3; // none, stencil, depth, depth-stencil\n// multiSampleCount = 1; // 1 bit // 2 states // value 0-1;\nfunction getGlobalStateKey(\n    stencilStateId: number,\n    multiSampleCount: number,\n    colorMask: number,\n    renderTarget: number,\n): number\n{\n    return (colorMask << 6) // Allocate the 4 bits for colorMask at the top\n         | (stencilStateId << 3) // Next 3 bits for stencilStateId\n         | (renderTarget << 1) // 2 bits for renderTarget\n         | multiSampleCount; // And 1 bit for multiSampleCount at the least significant position\n}\n\ntype PipeHash = Record<number, GPURenderPipeline>;\n\n/**\n * A system that creates and manages the GPU pipelines.\n *\n * Caching Mechanism: At its core, the system employs a two-tiered caching strategy to minimize\n * the redundant creation of GPU pipelines (or \"pipes\"). This strategy is based on generating unique\n * keys that represent the state of the graphics settings and the specific requirements of the\n * item being rendered. By caching these pipelines, subsequent draw calls with identical configurations\n * can reuse existing pipelines instead of generating new ones.\n *\n * State Management: The system differentiates between \"global\" state properties (like color masks\n * and stencil masks, which do not change frequently) and properties that may vary between draw calls\n * (such as geometry, shaders, and blend modes). Unique keys are generated for both these categories\n * using getStateKey for global state and getGraphicsStateKey for draw-specific settings. These keys are\n * then then used to caching the pipe. The next time we need a pipe we can check\n * the cache by first looking at the state cache and then the pipe cache.\n * @memberof rendering\n */\nexport class PipelineSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'pipeline',\n    } as const;\n    private readonly _renderer: WebGPURenderer;\n\n    protected CONTEXT_UID: number;\n\n    private _moduleCache: Record<string, GPUShaderModule> = Object.create(null);\n    private _bufferLayoutsCache: Record<number, GPUVertexBufferLayout[]> = Object.create(null);\n    private readonly _bindingNamesCache: Record<string, Record<string, string>> = Object.create(null);\n\n    private _pipeCache: PipeHash = Object.create(null);\n    private readonly _pipeStateCaches: Record<number, PipeHash> = Object.create(null);\n\n    private _gpu: GPU;\n    private _stencilState: StencilState;\n\n    private _stencilMode: STENCIL_MODES;\n    private _colorMask = 0b1111;\n    private _multisampleCount = 1;\n    private _depthStencilAttachment: 0 | 1;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n        this.setStencilMode(STENCIL_MODES.DISABLED);\n\n        this._updatePipeHash();\n    }\n\n    public setMultisampleCount(multisampleCount: number): void\n    {\n        if (this._multisampleCount === multisampleCount) return;\n\n        this._multisampleCount = multisampleCount;\n\n        this._updatePipeHash();\n    }\n\n    public setRenderTarget(renderTarget: GpuRenderTarget)\n    {\n        this._multisampleCount = renderTarget.msaaSamples;\n        this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;\n\n        this._updatePipeHash();\n    }\n\n    public setColorMask(colorMask: number): void\n    {\n        if (this._colorMask === colorMask) return;\n\n        this._colorMask = colorMask;\n\n        this._updatePipeHash();\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES): void\n    {\n        if (this._stencilMode === stencilMode) return;\n\n        this._stencilMode = stencilMode;\n        this._stencilState = GpuStencilModesToPixi[stencilMode];\n\n        this._updatePipeHash();\n    }\n\n    public setPipeline(geometry: Geometry, program: GpuProgram, state: State, passEncoder: GPURenderPassEncoder): void\n    {\n        const pipeline = this.getPipeline(geometry, program, state);\n\n        passEncoder.setPipeline(pipeline);\n    }\n\n    public getPipeline(\n        geometry: Geometry,\n        program: GpuProgram,\n        state: State,\n        topology?: Topology,\n    ): GPURenderPipeline\n    {\n        if (!geometry._layoutKey)\n        {\n            ensureAttributes(geometry, program.attributeData);\n\n            // prepare the geometry for the pipeline\n            this._generateBufferKey(geometry);\n        }\n\n        topology = topology || geometry.topology;\n\n        // now we have set the Ids - the key is different...\n        // eslint-disable-next-line max-len\n        const key = getGraphicsStateKey(\n            geometry._layoutKey,\n            program._layoutKey,\n            state.data,\n            state._blendModeId,\n            topologyStringToId[topology],\n        );\n\n        if (this._pipeCache[key]) return this._pipeCache[key];\n\n        this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);\n\n        return this._pipeCache[key];\n    }\n\n    private _createPipeline(geometry: Geometry, program: GpuProgram, state: State, topology: Topology): GPURenderPipeline\n    {\n        const device = this._gpu.device;\n\n        const buffers = this._createVertexBufferLayouts(geometry, program);\n\n        const blendModes = this._renderer.state.getColorTargets(state);\n\n        blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;\n\n        const layout = this._renderer.shader.getProgramData(program).pipeline;\n\n        const descriptor: GPURenderPipelineDescriptor = {\n            // TODO later check if its helpful to create..\n            // layout,\n            vertex: {\n                module: this._getModule(program.vertex.source),\n                entryPoint: program.vertex.entryPoint,\n                // geometry..\n                buffers,\n            },\n            fragment: {\n                module: this._getModule(program.fragment.source),\n                entryPoint: program.fragment.entryPoint,\n                targets: blendModes,\n            },\n            primitive: {\n                topology,\n                cullMode: state.cullMode,\n            },\n            layout,\n            multisample: {\n                count: this._multisampleCount,\n            },\n            // depthStencil,\n            label: `PIXI Pipeline`,\n        };\n\n        // only apply if the texture has stencil or depth\n        if (this._depthStencilAttachment)\n        {\n            // mask states..\n            descriptor.depthStencil = {\n                ...this._stencilState,\n                format: 'depth24plus-stencil8',\n                depthWriteEnabled: state.depthTest,\n                depthCompare: state.depthTest ? 'less' : 'always',\n            };\n        }\n\n        const pipeline = device.createRenderPipeline(descriptor);\n\n        return pipeline;\n    }\n\n    private _getModule(code: string): GPUShaderModule\n    {\n        return this._moduleCache[code] || this._createModule(code);\n    }\n\n    private _createModule(code: string): GPUShaderModule\n    {\n        const device = this._gpu.device;\n\n        this._moduleCache[code] = device.createShaderModule({\n            code,\n        });\n\n        return this._moduleCache[code];\n    }\n\n    private _generateBufferKey(geometry: Geometry): number\n    {\n        const keyGen = [];\n        let index = 0;\n        // generate a key..\n\n        const attributeKeys = Object.keys(geometry.attributes).sort();\n\n        for (let i = 0; i < attributeKeys.length; i++)\n        {\n            const attribute = geometry.attributes[attributeKeys[i]];\n\n            keyGen[index++] = attribute.offset;\n            keyGen[index++] = attribute.format;\n            keyGen[index++] = attribute.stride;\n            keyGen[index++] = attribute.instance;\n        }\n\n        const stringKey = keyGen.join('|');\n\n        geometry._layoutKey = createIdFromString(stringKey, 'geometry');\n\n        return geometry._layoutKey;\n    }\n\n    private _generateAttributeLocationsKey(program: GpuProgram): number\n    {\n        const keyGen = [];\n        let index = 0;\n        // generate a key..\n\n        const attributeKeys = Object.keys(program.attributeData).sort();\n\n        for (let i = 0; i < attributeKeys.length; i++)\n        {\n            const attribute = program.attributeData[attributeKeys[i]];\n\n            keyGen[index++] = attribute.location;\n        }\n\n        const stringKey = keyGen.join('|');\n\n        program._attributeLocationsKey = createIdFromString(stringKey, 'programAttributes');\n\n        return program._attributeLocationsKey;\n    }\n\n    /**\n     * Returns a hash of buffer names mapped to bind locations.\n     * This is used to bind the correct buffer to the correct location in the shader.\n     * @param geometry - The geometry where to get the buffer names\n     * @param program - The program where to get the buffer names\n     * @returns An object of buffer names mapped to the bind location.\n     */\n    public getBufferNamesToBind(geometry: Geometry, program: GpuProgram): Record<string, string>\n    {\n        const key = (geometry._layoutKey << 16) | program._attributeLocationsKey;\n\n        if (this._bindingNamesCache[key]) return this._bindingNamesCache[key];\n\n        const data = this._createVertexBufferLayouts(geometry, program);\n\n        // now map the data to the buffers..\n        const bufferNamesToBind: Record<string, string> = Object.create(null);\n\n        const attributeData = program.attributeData;\n\n        for (let i = 0; i < data.length; i++)\n        {\n            for (const j in attributeData)\n            {\n                if (attributeData[j].location === i)\n                {\n                    bufferNamesToBind[i] = j;\n                    break;\n                }\n            }\n        }\n\n        this._bindingNamesCache[key] = bufferNamesToBind;\n\n        return bufferNamesToBind;\n    }\n\n    private _createVertexBufferLayouts(geometry: Geometry, program: GpuProgram): GPUVertexBufferLayout[]\n    {\n        if (!program._attributeLocationsKey) this._generateAttributeLocationsKey(program);\n\n        const key = (geometry._layoutKey << 16) | program._attributeLocationsKey;\n\n        if (this._bufferLayoutsCache[key])\n        {\n            return this._bufferLayoutsCache[key];\n        }\n\n        const vertexBuffersLayout: GPUVertexBufferLayout[] = [];\n\n        geometry.buffers.forEach((buffer) =>\n        {\n            const bufferEntry: GPUVertexBufferLayout = {\n                arrayStride: 0,\n                stepMode: 'vertex',\n                attributes: [],\n            };\n\n            const bufferEntryAttributes = bufferEntry.attributes as GPUVertexAttribute[];\n\n            for (const i in program.attributeData)\n            {\n                const attribute = geometry.attributes[i];\n\n                if ((attribute.divisor ?? 1) !== 1)\n                {\n                    // TODO: Maybe emulate divisor with storage_buffers/float_textures?\n                    // For now just issue a warning\n                    warn(`Attribute ${i} has an invalid divisor value of '${attribute.divisor}'. `\n                        + 'WebGPU only supports a divisor value of 1');\n                }\n\n                if (attribute.buffer === buffer)\n                {\n                    bufferEntry.arrayStride = attribute.stride;\n                    bufferEntry.stepMode = attribute.instance ? 'instance' : 'vertex';\n\n                    bufferEntryAttributes.push({\n                        shaderLocation: program.attributeData[i].location,\n                        offset: attribute.offset,\n                        format: attribute.format,\n                    });\n                }\n            }\n\n            if (bufferEntryAttributes.length)\n            {\n                vertexBuffersLayout.push(bufferEntry);\n            }\n        });\n\n        this._bufferLayoutsCache[key] = vertexBuffersLayout;\n\n        return vertexBuffersLayout;\n    }\n\n    private _updatePipeHash(): void\n    {\n        const key = getGlobalStateKey(\n            this._stencilMode,\n            this._multisampleCount,\n            this._colorMask,\n            this._depthStencilAttachment\n        );\n\n        if (!this._pipeStateCaches[key])\n        {\n            this._pipeStateCaches[key] = Object.create(null);\n        }\n\n        this._pipeCache = this._pipeStateCaches[key];\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n        this._bufferLayoutsCache = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}