{"ast":null,"code":"import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup.mjs';\nimport { DefaultBatcher } from '../../../rendering/batcher/shared/DefaultBatcher.mjs';\nimport { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet.mjs';\nimport { deprecation, v8_3_4 } from '../../../utils/logging/deprecation.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { buildContextBatches } from './utils/buildContextBatches.mjs';\n\"use strict\";\nclass GpuGraphicsContext {\n  constructor() {\n    this.batches = [];\n    this.geometryData = {\n      vertices: [],\n      uvs: [],\n      indices: []\n    };\n  }\n}\nclass GraphicsContextRenderData {\n  constructor() {\n    this.batcher = new DefaultBatcher();\n    this.instructions = new InstructionSet();\n  }\n  init() {\n    this.instructions.reset();\n  }\n  /**\n   * @deprecated since version 8.0.0\n   * Use `batcher.geometry` instead.\n   * @see {Batcher#geometry}\n   */\n  get geometry() {\n    deprecation(v8_3_4, \"GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.\");\n    return this.batcher.geometry;\n  }\n}\nconst _GraphicsContextSystem = class _GraphicsContextSystem {\n  constructor() {\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    this._gpuContextHash = {};\n    // used for non-batchable graphics\n    this._graphicsDataContextHash = /* @__PURE__ */Object.create(null);\n  }\n  /**\n   * Runner init called, update the default options\n   * @ignore\n   */\n  init(options) {\n    _GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? _GraphicsContextSystem.defaultOptions.bezierSmoothness;\n  }\n  getContextRenderData(context) {\n    return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n  }\n  // Context management functions\n  updateGpuContext(context) {\n    let gpuContext = this._gpuContextHash[context.uid] || this._initContext(context);\n    if (context.dirty) {\n      if (gpuContext) {\n        this._cleanGraphicsContextData(context);\n      } else {\n        gpuContext = this._initContext(context);\n      }\n      buildContextBatches(context, gpuContext);\n      const batchMode = context.batchMode;\n      if (context.customShader || batchMode === \"no-batch\") {\n        gpuContext.isBatchable = false;\n      } else if (batchMode === \"auto\") {\n        gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;\n      }\n      context.dirty = false;\n    }\n    return gpuContext;\n  }\n  getGpuContext(context) {\n    return this._gpuContextHash[context.uid] || this._initContext(context);\n  }\n  _initContextRenderData(context) {\n    const graphicsData = BigPool.get(GraphicsContextRenderData);\n    const {\n      batches,\n      geometryData\n    } = this._gpuContextHash[context.uid];\n    const vertexSize = geometryData.vertices.length;\n    const indexSize = geometryData.indices.length;\n    for (let i = 0; i < batches.length; i++) {\n      batches[i].applyTransform = false;\n    }\n    const batcher = graphicsData.batcher;\n    batcher.ensureAttributeBuffer(vertexSize);\n    batcher.ensureIndexBuffer(indexSize);\n    batcher.begin();\n    for (let i = 0; i < batches.length; i++) {\n      const batch = batches[i];\n      batcher.add(batch);\n    }\n    batcher.finish(graphicsData.instructions);\n    const geometry = batcher.geometry;\n    geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n    geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n    const drawBatches = batcher.batches;\n    for (let i = 0; i < drawBatches.length; i++) {\n      const batch = drawBatches[i];\n      batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);\n    }\n    this._graphicsDataContextHash[context.uid] = graphicsData;\n    return graphicsData;\n  }\n  _initContext(context) {\n    const gpuContext = new GpuGraphicsContext();\n    gpuContext.context = context;\n    this._gpuContextHash[context.uid] = gpuContext;\n    context.on(\"destroy\", this.onGraphicsContextDestroy, this);\n    return this._gpuContextHash[context.uid];\n  }\n  onGraphicsContextDestroy(context) {\n    this._cleanGraphicsContextData(context);\n    context.off(\"destroy\", this.onGraphicsContextDestroy, this);\n    this._gpuContextHash[context.uid] = null;\n  }\n  _cleanGraphicsContextData(context) {\n    const gpuContext = this._gpuContextHash[context.uid];\n    if (!gpuContext.isBatchable) {\n      if (this._graphicsDataContextHash[context.uid]) {\n        BigPool.return(this.getContextRenderData(context));\n        this._graphicsDataContextHash[context.uid] = null;\n      }\n    }\n    if (gpuContext.batches) {\n      gpuContext.batches.forEach(batch => {\n        BigPool.return(batch);\n      });\n    }\n  }\n  destroy() {\n    for (const i in this._gpuContextHash) {\n      if (this._gpuContextHash[i]) {\n        this.onGraphicsContextDestroy(this._gpuContextHash[i].context);\n      }\n    }\n  }\n};\n/** @ignore */\n_GraphicsContextSystem.extension = {\n  type: [ExtensionType.WebGLSystem, ExtensionType.WebGPUSystem, ExtensionType.CanvasSystem],\n  name: \"graphicsContext\"\n};\n/** The default options for the GraphicsContextSystem. */\n_GraphicsContextSystem.defaultOptions = {\n  /**\n   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n   * @default 0.5\n   */\n  bezierSmoothness: 0.5\n};\nlet GraphicsContextSystem = _GraphicsContextSystem;\nexport { GpuGraphicsContext, GraphicsContextRenderData, GraphicsContextSystem };","map":{"version":3,"names":["GpuGraphicsContext","constructor","batches","geometryData","vertices","uvs","indices","GraphicsContextRenderData","batcher","DefaultBatcher","instructions","InstructionSet","init","reset","geometry","deprecation","v8_3_4","_GraphicsContextSystem","_gpuContextHash","_graphicsDataContextHash","Object","create","options","defaultOptions","bezierSmoothness","getContextRenderData","context","uid","_initContextRenderData","updateGpuContext","gpuContext","_initContext","dirty","_cleanGraphicsContextData","buildContextBatches","batchMode","customShader","isBatchable","length","getGpuContext","graphicsData","BigPool","get","vertexSize","indexSize","i","applyTransform","ensureAttributeBuffer","ensureIndexBuffer","begin","batch","add","finish","indexBuffer","setDataWithSize","buffers","attributeBuffer","float32View","attributeSize","drawBatches","bindGroup","getTextureBatchBindGroup","textures","count","on","onGraphicsContextDestroy","off","return","forEach","destroy","extension","type","ExtensionType","WebGLSystem","WebGPUSystem","CanvasSystem","name","GraphicsContextSystem"],"sources":["/workspaces/royal-games-updated/node_modules/pixi.js/src/scene/graphics/shared/GraphicsContextSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup';\nimport { DefaultBatcher } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport { deprecation, v8_3_4 } from '../../../utils/logging/deprecation';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { buildContextBatches } from './utils/buildContextBatches';\n\nimport type { Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { BatchableGraphics } from './BatchableGraphics';\nimport type { GraphicsContext } from './GraphicsContext';\n\ninterface GeometryData\n{\n    vertices: number[];\n    uvs: number[];\n    indices: number[];\n}\n\n/**\n * A class that holds batchable graphics data for a GraphicsContext.\n * @memberof rendering\n * @ignore\n */\nexport class GpuGraphicsContext\n{\n    public isBatchable: boolean;\n    public context: GraphicsContext;\n\n    public batches: BatchableGraphics[] = [];\n    public geometryData: GeometryData = {\n        vertices: [],\n        uvs: [],\n        indices: [],\n    };\n    public graphicsData: GraphicsContextRenderData;\n}\n\n/**\n * A class that holds the render data for a GraphicsContext.\n * @memberof rendering\n * @ignore\n */\nexport class GraphicsContextRenderData\n{\n    public batcher: Batcher = new DefaultBatcher();\n    public instructions = new InstructionSet();\n\n    public init()\n    {\n        this.instructions.reset();\n    }\n\n    /**\n     * @deprecated since version 8.0.0\n     * Use `batcher.geometry` instead.\n     * @see {Batcher#geometry}\n     */\n    get geometry()\n    {\n        // eslint-disable-next-line max-len\n        deprecation(v8_3_4, 'GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.');\n\n        return this.batcher.geometry;\n    }\n}\n\n/**\n * Options for the GraphicsContextSystem.\n * @memberof rendering\n */\nexport interface GraphicsContextSystemOptions\n{\n    /** A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother) */\n    bezierSmoothness?: number;\n}\n\n/**\n * A system that manages the rendering of GraphicsContexts.\n * @memberof rendering\n */\nexport class GraphicsContextSystem implements System<GraphicsContextSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'graphicsContext'\n    } as const;\n\n    /** The default options for the GraphicsContextSystem. */\n    public static readonly defaultOptions: GraphicsContextSystemOptions = {\n        /**\n         * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)\n         * @default 0.5\n         */\n        bezierSmoothness: 0.5,\n    };\n\n    // the root context batches, used to either make a batch or geometry\n    // all graphics use this as a base\n    private _gpuContextHash: Record<number, GpuGraphicsContext> = {};\n    // used for non-batchable graphics\n    private _graphicsDataContextHash: Record<number, GraphicsContextRenderData> = Object.create(null);\n\n    /**\n     * Runner init called, update the default options\n     * @ignore\n     */\n    public init(options?: GraphicsContextSystemOptions)\n    {\n        GraphicsContextSystem.defaultOptions.bezierSmoothness = options?.bezierSmoothness\n            ?? GraphicsContextSystem.defaultOptions.bezierSmoothness;\n    }\n\n    public getContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);\n    }\n\n    // Context management functions\n    public updateGpuContext(context: GraphicsContext)\n    {\n        let gpuContext: GpuGraphicsContext = this._gpuContextHash[context.uid]\n\n            || this._initContext(context);\n\n        if (context.dirty)\n        {\n            if (gpuContext)\n            {\n                this._cleanGraphicsContextData(context);\n            }\n            else\n            {\n                gpuContext = this._initContext(context);\n            }\n\n            buildContextBatches(context, gpuContext);\n\n            const batchMode = context.batchMode;\n\n            if (context.customShader || batchMode === 'no-batch')\n            {\n                gpuContext.isBatchable = false;\n            }\n            else if (batchMode === 'auto')\n            {\n                gpuContext.isBatchable = (gpuContext.geometryData.vertices.length < 400);\n            }\n\n            context.dirty = false;\n        }\n\n        return gpuContext;\n    }\n\n    public getGpuContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        return this._gpuContextHash[context.uid] || this._initContext(context);\n    }\n\n    private _initContextRenderData(context: GraphicsContext): GraphicsContextRenderData\n    {\n        const graphicsData: GraphicsContextRenderData = BigPool.get(GraphicsContextRenderData);// ();\n\n        const { batches, geometryData } = this._gpuContextHash[context.uid];\n\n        const vertexSize = geometryData.vertices.length;\n        const indexSize = geometryData.indices.length;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            batches[i].applyTransform = false;\n        }\n\n        const batcher = graphicsData.batcher;\n\n        // TODO we can pool buffers here eventually..\n        batcher.ensureAttributeBuffer(vertexSize);\n        batcher.ensureIndexBuffer(indexSize);\n\n        batcher.begin();\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batcher.add(batch);\n        }\n\n        batcher.finish(graphicsData.instructions);\n\n        const geometry = batcher.geometry;\n\n        // not to self - this works as we are assigning the batchers array buffer\n        // once its up loaded - this buffer is then put back in the pool to be reused.\n        // this mean we don't have to creating new Batchers for each graphics items\n        geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);\n        geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);\n\n        const drawBatches = batcher.batches;\n\n        for (let i = 0; i < drawBatches.length; i++)\n        {\n            const batch = drawBatches[i];\n\n            batch.bindGroup = getTextureBatchBindGroup(batch.textures.textures, batch.textures.count);\n        }\n\n        this._graphicsDataContextHash[context.uid] = graphicsData;\n\n        return graphicsData;\n    }\n\n    private _initContext(context: GraphicsContext): GpuGraphicsContext\n    {\n        const gpuContext = new GpuGraphicsContext();\n\n        gpuContext.context = context;\n\n        this._gpuContextHash[context.uid] = gpuContext;\n\n        context.on('destroy', this.onGraphicsContextDestroy, this);\n\n        return this._gpuContextHash[context.uid];\n    }\n\n    protected onGraphicsContextDestroy(context: GraphicsContext)\n    {\n        this._cleanGraphicsContextData(context);\n\n        context.off('destroy', this.onGraphicsContextDestroy, this);\n\n        this._gpuContextHash[context.uid] = null;\n    }\n\n    private _cleanGraphicsContextData(context: GraphicsContext)\n    {\n        const gpuContext: GpuGraphicsContext = this._gpuContextHash[context.uid];\n\n        if (!gpuContext.isBatchable)\n        {\n            if (this._graphicsDataContextHash[context.uid])\n            {\n                BigPool.return(this.getContextRenderData(context) as PoolItem);\n\n                // we will rebuild this...\n                this._graphicsDataContextHash[context.uid] = null;\n            }\n        }\n\n        if (gpuContext.batches)\n        {\n            gpuContext.batches.forEach((batch) =>\n            {\n                BigPool.return(batch as PoolItem);\n            });\n        }\n    }\n\n    public destroy()\n    {\n        // Clean up all graphics contexts\n\n        for (const i in this._gpuContextHash)\n        {\n            if (this._gpuContextHash[i])\n            {\n                this.onGraphicsContextDestroy(this._gpuContextHash[i].context);\n            }\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}