{"ast":null,"code":"import { Cache } from '../../assets/cache/Cache.mjs';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint.mjs';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture.mjs';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation.mjs';\nimport { Transform } from '../../utils/misc/Transform.mjs';\nimport { ViewContainer } from '../view/View.mjs';\n\"use strict\";\nconst _TilingSprite = class _TilingSprite extends ViewContainer {\n  constructor(...args) {\n    let options = args[0] || {};\n    if (options instanceof Texture) {\n      options = {\n        texture: options\n      };\n    }\n    if (args.length > 1) {\n      deprecation(v8_0_0, \"use new TilingSprite({ texture, width:100, height:100 }) instead\");\n      options.width = args[1];\n      options.height = args[2];\n    }\n    options = {\n      ..._TilingSprite.defaultOptions,\n      ...options\n    };\n    const {\n      texture,\n      anchor,\n      tilePosition,\n      tileScale,\n      tileRotation,\n      width,\n      height,\n      applyAnchorToTexture,\n      roundPixels,\n      ...rest\n    } = options ?? {};\n    super({\n      label: \"TilingSprite\",\n      ...rest\n    });\n    this.renderPipeId = \"tilingSprite\";\n    this.batched = true;\n    this.allowChildren = false;\n    this._anchor = new ObservablePoint({\n      _onUpdate: () => {\n        this.onViewUpdate();\n      }\n    });\n    this._applyAnchorToTexture = applyAnchorToTexture;\n    this.texture = texture;\n    this._width = width ?? texture.width;\n    this._height = height ?? texture.height;\n    this._tileTransform = new Transform({\n      observer: {\n        _onUpdate: () => this.onViewUpdate()\n      }\n    });\n    if (anchor) this.anchor = anchor;\n    this.tilePosition = tilePosition;\n    this.tileScale = tileScale;\n    this.tileRotation = tileRotation;\n    this.roundPixels = roundPixels ?? false;\n  }\n  /**\n   * Creates a new tiling sprite.\n   * @param source - The source to create the texture from.\n   * @param options - The options for creating the tiling sprite.\n   * @returns A new tiling sprite.\n   */\n  static from(source, options = {}) {\n    if (typeof source === \"string\") {\n      return new _TilingSprite({\n        texture: Cache.get(source),\n        ...options\n      });\n    }\n    return new _TilingSprite({\n      texture: source,\n      ...options\n    });\n  }\n  /**\n   * Changes frame clamping in corresponding textureMatrix\n   * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n   * @default 0.5\n   * @member {number}\n   */\n  get clampMargin() {\n    return this._texture.textureMatrix.clampMargin;\n  }\n  set clampMargin(value) {\n    this._texture.textureMatrix.clampMargin = value;\n  }\n  /**\n   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n   * and passed to the constructor.\n   *\n   * The default is `(0,0)`, this means the sprite's origin is the top left.\n   *\n   * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n   *\n   * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n   *\n   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n   * @example\n   * import { TilingSprite } from 'pixi.js';\n   *\n   * const sprite = new TilingSprite({texture: Texture.WHITE});\n   * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n   */\n  get anchor() {\n    return this._anchor;\n  }\n  set anchor(value) {\n    typeof value === \"number\" ? this._anchor.set(value) : this._anchor.copyFrom(value);\n  }\n  /** The offset of the image that is being tiled. */\n  get tilePosition() {\n    return this._tileTransform.position;\n  }\n  set tilePosition(value) {\n    this._tileTransform.position.copyFrom(value);\n  }\n  /** The scaling of the image that is being tiled. */\n  get tileScale() {\n    return this._tileTransform.scale;\n  }\n  set tileScale(value) {\n    typeof value === \"number\" ? this._tileTransform.scale.set(value) : this._tileTransform.scale.copyFrom(value);\n  }\n  set tileRotation(value) {\n    this._tileTransform.rotation = value;\n  }\n  /** The rotation of the image that is being tiled. */\n  get tileRotation() {\n    return this._tileTransform.rotation;\n  }\n  /** The transform of the image that is being tiled. */\n  get tileTransform() {\n    return this._tileTransform;\n  }\n  /**\n   * The local bounds of the sprite.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    if (this._boundsDirty) {\n      this._updateBounds();\n      this._boundsDirty = false;\n    }\n    return this._bounds;\n  }\n  set texture(value) {\n    value || (value = Texture.EMPTY);\n    const currentTexture = this._texture;\n    if (currentTexture === value) return;\n    if (currentTexture && currentTexture.dynamic) currentTexture.off(\"update\", this.onViewUpdate, this);\n    if (value.dynamic) value.on(\"update\", this.onViewUpdate, this);\n    this._texture = value;\n    this.onViewUpdate();\n  }\n  /** The texture that the sprite is using. */\n  get texture() {\n    return this._texture;\n  }\n  /** The width of the tiling area. */\n  set width(value) {\n    this._width = value;\n    this.onViewUpdate();\n  }\n  get width() {\n    return this._width;\n  }\n  set height(value) {\n    this._height = value;\n    this.onViewUpdate();\n  }\n  /** The height of the tiling area. */\n  get height() {\n    return this._height;\n  }\n  /**\n   * Sets the size of the TilingSprite to the specified width and height.\n   * This is faster than setting the width and height separately.\n   * @param value - This can be either a number or a [Size]{@link Size} object.\n   * @param height - The height to set. Defaults to the value of `width` if not provided.\n   */\n  setSize(value, height) {\n    if (typeof value === \"object\") {\n      height = value.height ?? value.width;\n      value = value.width;\n    }\n    this._width = value;\n    this._height = height ?? value;\n    this.onViewUpdate();\n  }\n  /**\n   * Retrieves the size of the TilingSprite as a [Size]{@link Size} object.\n   * This is faster than get the width and height separately.\n   * @param out - Optional object to store the size in.\n   * @returns - The size of the TilingSprite.\n   */\n  getSize(out) {\n    out || (out = {});\n    out.width = this._width;\n    out.height = this._height;\n    return out;\n  }\n  _updateBounds() {\n    const bounds = this._bounds;\n    const anchor = this._anchor;\n    const width = this._width;\n    const height = this._height;\n    bounds.maxX = -anchor._x * width;\n    bounds.minX = bounds.maxX + width;\n    bounds.maxY = -anchor._y * height;\n    bounds.minY = bounds.maxY + height;\n  }\n  /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    const _bounds = this.bounds;\n    bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const width = this._width;\n    const height = this._height;\n    const x1 = -width * this._anchor._x;\n    let y1 = 0;\n    if (point.x >= x1 && point.x <= x1 + width) {\n      y1 = -height * this._anchor._y;\n      if (point.y >= y1 && point.y <= y1 + height) return true;\n    }\n    return false;\n  }\n  onViewUpdate() {\n    this._boundsDirty = true;\n    this._didTilingSpriteUpdate = true;\n    this._didViewChangeTick++;\n    if (this.didViewUpdate) return;\n    this.didViewUpdate = true;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.onChildViewUpdate(this);\n    }\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    this._anchor = null;\n    this._tileTransform = null;\n    this._bounds = null;\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      this._texture.destroy(destroyTextureSource);\n    }\n    this._texture = null;\n  }\n};\n/** default options for the TilingSprite */\n_TilingSprite.defaultOptions = {\n  /** The texture to use for the sprite. */\n  texture: Texture.EMPTY,\n  /** The anchor point of the sprite */\n  anchor: {\n    x: 0,\n    y: 0\n  },\n  /** The offset of the image that is being tiled. */\n  tilePosition: {\n    x: 0,\n    y: 0\n  },\n  /** Scaling of the image that is being tiled. */\n  tileScale: {\n    x: 1,\n    y: 1\n  },\n  /** The rotation of the image that is being tiled. */\n  tileRotation: 0,\n  /** TODO */\n  applyAnchorToTexture: false\n};\nlet TilingSprite = _TilingSprite;\nexport { TilingSprite };","map":{"version":3,"names":["_TilingSprite","ViewContainer","constructor","args","options","Texture","texture","length","deprecation","v8_0_0","width","height","defaultOptions","anchor","tilePosition","tileScale","tileRotation","applyAnchorToTexture","roundPixels","rest","label","renderPipeId","batched","allowChildren","_anchor","ObservablePoint","_onUpdate","onViewUpdate","_applyAnchorToTexture","_width","_height","_tileTransform","Transform","observer","from","source","Cache","get","clampMargin","_texture","textureMatrix","value","set","copyFrom","position","scale","rotation","tileTransform","bounds","_boundsDirty","_updateBounds","_bounds","EMPTY","currentTexture","dynamic","off","on","setSize","getSize","out","maxX","_x","minX","maxY","_y","minY","addBounds","addFrame","containsPoint","point","x1","y1","x","y","_didTilingSpriteUpdate","_didViewChangeTick","didViewUpdate","renderGroup","parentRenderGroup","onChildViewUpdate","destroy","destroyTexture","destroyTextureSource","textureSource","TilingSprite"],"sources":["/workspaces/royal-games-updated/node_modules/pixi.js/src/scene/sprite-tiling/TilingSprite.ts"],"sourcesContent":["import { Cache } from '../../assets/cache/Cache';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { Transform } from '../../utils/misc/Transform';\nimport { ViewContainer } from '../view/View';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { Instruction } from '../../rendering/renderers/shared/instructions/Instruction';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { Bounds } from '../container/bounds/Bounds';\nimport type { ContainerOptions } from '../container/Container';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * Constructor options used for `TilingSprite` instances. Extends {@link scene.TilingSpriteViewOptions}\n * ```js\n * const tilingSprite = new TilingSprite({\n *    texture: Texture.from('assets/image.png'),\n *    width: 100,\n *    height: 100,\n *    tilePosition: { x: 100, y: 100 },\n *    tileScale: { x: 2, y: 2 },\n * });\n * ```\n * @see {@link scene.TilingSprite}\n * @see {@link scene.TilingSpriteViewOptions}\n * @memberof scene\n */\nexport interface TilingSpriteOptions extends ContainerOptions\n{\n    /**\n     * The anchor point of the sprite\n     * @default {x: 0, y: 0}\n     */\n    anchor?: PointData\n    /**\n     * The offset of the image that is being tiled.\n     * @default {x: 0, y: 0}\n     */\n    tilePosition?: PointData\n    /**\n     * Scaling of the image that is being tiled.\n     * @default {x: 1, y: 1}\n     */\n    tileScale?: PointData\n    /**\n     * The rotation of the image that is being tiled.\n     * @default 0\n     */\n    tileRotation?: number\n    /**\n     * The texture to use for the sprite.\n     * @default Texture.WHITE\n     */\n    texture?: Texture\n    /**\n     * The width of the tiling sprite. #\n     * @default 256\n     */\n    width?: number\n    /**\n     * The height of the tiling sprite.\n     * @default 256\n     */\n    height?: number\n    // TODO needs a better name..\n    /**\n     * @todo\n     * @default false\n     */\n    applyAnchorToTexture?: boolean\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * A tiling sprite is a fast way of rendering a tiling image.\n * @example\n * const tilingSprite = new TilingSprite({\n *    texture: Texture.from('assets/image.png'),\n *    width: 100,\n *    height: 100,\n * });\n *\n * tilingSprite.tilePosition.x = 100;\n * tilingSprite.tilePosition.y = 100;\n *\n * app.stage.addChild(tilingSprite);\n * @memberof scene\n * @extends scene.Container\n */\nexport class TilingSprite extends ViewContainer implements View, Instruction\n{\n    /**\n     * Creates a new tiling sprite.\n     * @param source - The source to create the texture from.\n     * @param options - The options for creating the tiling sprite.\n     * @returns A new tiling sprite.\n     */\n    public static from(source: Texture | string, options: TilingSpriteOptions = {})\n    {\n        if (typeof source === 'string')\n        {\n            return new TilingSprite({\n                texture: Cache.get(source),\n                ...options,\n            });\n        }\n\n        return new TilingSprite({\n            texture: source,\n            ...options,\n        });\n    }\n\n    /** default options for the TilingSprite */\n    public static defaultOptions: TilingSpriteOptions = {\n        /** The texture to use for the sprite. */\n        texture: Texture.EMPTY,\n        /** The anchor point of the sprite */\n        anchor: { x: 0, y: 0 },\n        /** The offset of the image that is being tiled. */\n        tilePosition: { x: 0, y: 0 },\n        /** Scaling of the image that is being tiled. */\n        tileScale: { x: 1, y: 1 },\n        /** The rotation of the image that is being tiled. */\n        tileRotation: 0,\n        /** TODO */\n        applyAnchorToTexture: false,\n    };\n\n    public override readonly renderPipeId: string = 'tilingSprite';\n    public readonly batched = true;\n\n    public _anchor: ObservablePoint;\n\n    public _tileTransform: Transform;\n    public _texture: Texture;\n    public _applyAnchorToTexture: boolean;\n    public _didTilingSpriteUpdate: boolean;\n\n    private _width: number;\n    private _height: number;\n\n    /**\n     * @param {rendering.Texture | scene.TilingSpriteOptions} options - The options for creating the tiling sprite.\n     */\n    constructor(options?: Texture | TilingSpriteOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(texture: Texture, width: number, height: number);\n    constructor(...args: [(Texture | TilingSpriteOptions)?] | [Texture, number, number])\n    {\n        let options = args[0] || {};\n\n        if (options instanceof Texture)\n        {\n            options = { texture: options };\n        }\n\n        if (args.length > 1)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new TilingSprite({ texture, width:100, height:100 }) instead');\n            // #endif\n\n            options.width = args[1];\n            options.height = args[2];\n        }\n\n        options = { ...TilingSprite.defaultOptions, ...options };\n\n        const {\n            texture,\n            anchor,\n            tilePosition,\n            tileScale,\n            tileRotation,\n            width,\n            height,\n            applyAnchorToTexture,\n            roundPixels,\n            ...rest\n        } = options ?? {};\n\n        super({\n\n            label: 'TilingSprite',\n            ...rest\n        });\n\n        this.allowChildren = false;\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                }\n            },\n        );\n\n        this._applyAnchorToTexture = applyAnchorToTexture;\n\n        this.texture = texture;\n        this._width = width ?? texture.width;\n        this._height = height ?? texture.height;\n\n        this._tileTransform = new Transform({\n            observer: {\n                _onUpdate: () => this.onViewUpdate(),\n            }\n        });\n\n        if (anchor) this.anchor = anchor;\n        this.tilePosition = tilePosition;\n        this.tileScale = tileScale;\n        this.tileRotation = tileRotation;\n\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    /**\n     * Changes frame clamping in corresponding textureMatrix\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     * @default 0.5\n     * @member {number}\n     */\n    get clampMargin()\n    {\n        return this._texture.textureMatrix.clampMargin;\n    }\n\n    set clampMargin(value: number)\n    {\n        this._texture.textureMatrix.clampMargin = value;\n    }\n\n    /**\n     * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n     * and passed to the constructor.\n     *\n     * The default is `(0,0)`, this means the sprite's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * import { TilingSprite } from 'pixi.js';\n     *\n     * const sprite = new TilingSprite({texture: Texture.WHITE});\n     * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /** The offset of the image that is being tiled. */\n    get tilePosition(): ObservablePoint\n    {\n        return this._tileTransform.position;\n    }\n\n    set tilePosition(value: PointData)\n    {\n        this._tileTransform.position.copyFrom(value);\n    }\n\n    /** The scaling of the image that is being tiled. */\n    get tileScale(): ObservablePoint\n    {\n        return this._tileTransform.scale;\n    }\n\n    set tileScale(value: PointData | number)\n    {\n        typeof value === 'number' ? this._tileTransform.scale.set(value) : this._tileTransform.scale.copyFrom(value);\n    }\n\n    set tileRotation(value)\n    {\n        this._tileTransform.rotation = value;\n    }\n\n    /** The rotation of the image that is being tiled. */\n    get tileRotation()\n    {\n        return this._tileTransform.rotation;\n    }\n\n    /** The transform of the image that is being tiled. */\n    get tileTransform()\n    {\n        return this._tileTransform;\n    }\n\n    /**\n     * The local bounds of the sprite.\n     * @type {rendering.Bounds}\n     */\n    get bounds()\n    {\n        if (this._boundsDirty)\n        {\n            this._updateBounds();\n            this._boundsDirty = false;\n        }\n\n        return this._bounds;\n    }\n\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        const currentTexture = this._texture;\n\n        if (currentTexture === value) return;\n\n        if (currentTexture && currentTexture.dynamic) currentTexture.off('update', this.onViewUpdate, this);\n        if (value.dynamic) value.on('update', this.onViewUpdate, this);\n\n        this._texture = value;\n\n        this.onViewUpdate();\n    }\n\n    /** The texture that the sprite is using. */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    /** The width of the tiling area. */\n    override set width(value: number)\n    {\n        this._width = value;\n        this.onViewUpdate();\n    }\n\n    override get width()\n    {\n        return this._width;\n    }\n\n    override set height(value: number)\n    {\n        this._height = value;\n        this.onViewUpdate();\n    }\n\n    /** The height of the tiling area. */\n    override get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * Sets the size of the TilingSprite to the specified width and height.\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number): void\n    {\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n\n        this._width = value;\n        this._height = height ?? value;\n\n        this.onViewUpdate();\n    }\n\n    /**\n     * Retrieves the size of the TilingSprite as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the TilingSprite.\n     */\n    public override getSize(out?: Size): Size\n    {\n        out ||= {} as Size;\n        out.width = this._width;\n        out.height = this._height;\n\n        return out;\n    }\n\n    protected override _updateBounds()\n    {\n        const bounds = this._bounds;\n\n        const anchor = this._anchor;\n\n        const width = this._width;\n        const height = this._height;\n\n        bounds.maxX = -anchor._x * width;\n        bounds.minX = bounds.maxX + width;\n\n        bounds.maxY = -anchor._y * height;\n        bounds.minY = bounds.maxY + height;\n    }\n\n    /**\n     * Adds the bounds of this object to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        const _bounds = this.bounds;\n\n        bounds.addFrame(\n            _bounds.minX,\n            _bounds.minY,\n            _bounds.maxX,\n            _bounds.maxY,\n        );\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public override containsPoint(point: PointData)\n    {\n        const width = this._width;\n        const height = this._height;\n        const x1 = -width * this._anchor._x;\n        let y1 = 0;\n\n        if (point.x >= x1 && point.x <= x1 + width)\n        {\n            y1 = -height * this._anchor._y;\n\n            if (point.y >= y1 && point.y <= y1 + height) return true;\n        }\n\n        return false;\n    }\n\n    public onViewUpdate()\n    {\n        this._boundsDirty = true;\n        this._didTilingSpriteUpdate = true;\n\n        this._didViewChangeTick++;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public override destroy(options: DestroyOptions = false)\n    {\n        super.destroy(options);\n\n        this._anchor = null;\n        this._tileTransform = null;\n        this._bounds = null;\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._texture = null;\n    }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}