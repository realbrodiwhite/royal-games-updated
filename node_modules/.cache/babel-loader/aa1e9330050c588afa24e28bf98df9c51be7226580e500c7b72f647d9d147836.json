{"ast":null,"code":"import { PlaneGeometry } from '../mesh-plane/PlaneGeometry.mjs';\nimport { applyProjectiveTransformationToPlane } from './utils/applyProjectiveTransformationToPlane.mjs';\nimport { compute2DProjection } from './utils/compute2DProjections.mjs';\n\"use strict\";\nclass PerspectivePlaneGeometry extends PlaneGeometry {\n  /**\n   * @param options - Options to be applied to MeshPlane\n   * @param options.width - The width of the plane\n   * @param options.height - The height of the plane\n   * @param options.verticesX - The amount of vertices on the x axis\n   * @param options.verticesY - The amount of vertices on the y axis\n   */\n  constructor(options) {\n    super(options);\n    this._projectionMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    const {\n      width,\n      height\n    } = options;\n    this.corners = [0, 0, width, 0, width, height, 0, height];\n  }\n  /**\n   * Will set the corners of the quad to the given coordinates\n   * Calculating the perspective so it looks correct!\n   * @param x0 - x coordinate of the first corner\n   * @param y0 - y coordinate of the first corner\n   * @param x1 - x coordinate of the second corner\n   * @param y1 - y coordinate of the second corner\n   * @param x2 - x coordinate of the third corner\n   * @param y2 - y coordinate of the third corner\n   * @param x3 - x coordinate of the fourth corner\n   * @param y3 - y coordinate of the fourth corner\n   */\n  setCorners(x0, y0, x1, y1, x2, y2, x3, y3) {\n    const corners = this.corners;\n    corners[0] = x0;\n    corners[1] = y0;\n    corners[2] = x1;\n    corners[3] = y1;\n    corners[4] = x2;\n    corners[5] = y2;\n    corners[6] = x3;\n    corners[7] = y3;\n    this.updateProjection();\n  }\n  /** Update the projection matrix based on the corners */\n  updateProjection() {\n    const {\n      width,\n      height\n    } = this;\n    const corners = this.corners;\n    const projectionMatrix = compute2DProjection(this._projectionMatrix, 0, 0,\n    // top-left source\n    corners[0], corners[1],\n    // top-left dest\n    width, 0,\n    // top-right source\n    corners[2], corners[3],\n    // top-right dest\n    width, height,\n    // bottom-right source\n    corners[4], corners[5],\n    // bottom-right dest\n    0, height,\n    // bottom-left source\n    corners[6], corners[7]\n    // bottom-left dest\n    );\n    applyProjectiveTransformationToPlane(width, height, this, projectionMatrix);\n  }\n}\nexport { PerspectivePlaneGeometry };","map":{"version":3,"names":["PerspectivePlaneGeometry","PlaneGeometry","constructor","options","_projectionMatrix","width","height","corners","setCorners","x0","y0","x1","y1","x2","y2","x3","y3","updateProjection","projectionMatrix","compute2DProjection","applyProjectiveTransformationToPlane"],"sources":["/workspaces/royal-games-updated/node_modules/pixi.js/src/scene/mesh-perspective/PerspectivePlaneGeometry.ts"],"sourcesContent":["import { PlaneGeometry } from '../mesh-plane/PlaneGeometry';\nimport { applyProjectiveTransformationToPlane } from './utils/applyProjectiveTransformationToPlane';\nimport { compute2DProjection } from './utils/compute2DProjections';\n\nimport type { ArrayFixed } from '../../utils/types';\nimport type { PlaneGeometryOptions } from '../mesh-plane/PlaneGeometry';\n\n/**\n * Constructor options used for `PerspectivePlaneGeometry` instances.\n * @memberof scene\n */\nexport interface PerspectivePlaneGeometryOptions extends PlaneGeometryOptions\n{\n    /** The width of the plane */\n    width: number;\n    /** The height of the plane */\n    height: number;\n}\n\n/**\n * A PerspectivePlaneGeometry allows you to draw a 2d plane with perspective. Where ever you move the corners\n * the texture will be projected to look like it is in 3d space. Great for mapping a 2D mesh into a 3D scene.\n *\n * IMPORTANT: This is not a full 3D mesh, it is a 2D mesh with a perspective projection applied to it :)\n *\n * ```js\n * const perspectivePlaneGeometry = new PerspectivePlaneGeometry({\n *  width: 100,\n *  height: 100,\n *  verticesX: 10,\n *  verticesY: 10,\n * });\n * ```\n * @see {@link scene.PerspectivePlaneGeometry}\n * @memberof scene\n */\nexport class PerspectivePlaneGeometry extends PlaneGeometry\n{\n    /** The corner points of the quad you can modify these directly, if you do make sure to call `updateProjection` */\n    public corners: [number, number, number, number, number, number, number, number];\n    private readonly _projectionMatrix: ArrayFixed<number, 9> = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n    /**\n     * @param options - Options to be applied to MeshPlane\n     * @param options.width - The width of the plane\n     * @param options.height - The height of the plane\n     * @param options.verticesX - The amount of vertices on the x axis\n     * @param options.verticesY - The amount of vertices on the y axis\n     */\n    constructor(options: PerspectivePlaneGeometryOptions)\n    {\n        super(options);\n\n        const { width, height } = options;\n\n        this.corners = [0, 0, width, 0, width, height, 0, height];\n    }\n\n    /**\n     * Will set the corners of the quad to the given coordinates\n     * Calculating the perspective so it looks correct!\n     * @param x0 - x coordinate of the first corner\n     * @param y0 - y coordinate of the first corner\n     * @param x1 - x coordinate of the second corner\n     * @param y1 - y coordinate of the second corner\n     * @param x2 - x coordinate of the third corner\n     * @param y2 - y coordinate of the third corner\n     * @param x3 - x coordinate of the fourth corner\n     * @param y3 - y coordinate of the fourth corner\n     */\n    public setCorners(x0: number, y0: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number)\n    {\n        const corners = this.corners;\n\n        corners[0] = x0;\n        corners[1] = y0;\n        corners[2] = x1;\n        corners[3] = y1;\n        corners[4] = x2;\n        corners[5] = y2;\n        corners[6] = x3;\n        corners[7] = y3;\n\n        this.updateProjection();\n    }\n\n    /** Update the projection matrix based on the corners */\n    public updateProjection()\n    {\n        const { width, height } = this;\n        const corners = this.corners;\n\n        const projectionMatrix = compute2DProjection(\n            this._projectionMatrix,\n            0, 0, // top-left source\n            corners[0], corners[1], // top-left dest\n            width, 0, // top-right source\n            corners[2], corners[3], // top-right dest\n            width, height, // bottom-right source\n            corners[4], corners[5], // bottom-right dest\n            0, height, // bottom-left source\n            corners[6], corners[7] // bottom-left dest\n        );\n\n        applyProjectiveTransformationToPlane(\n            width,\n            height,\n            this,\n            projectionMatrix\n        );\n    }\n}\n\n"],"mappings":";;;;AAoCO,MAAMA,wBAAA,SAAiCC,aAC9C;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAYIC,YAAYC,OACZ;IACI,MAAMA,OAAO;IAXA,KAAAC,iBAAA,GAA2C,CAAC,GAAG,CAAG,KAAG,GAAG,CAAG,KAAG,CAAG,KAAG,CAAC;IAa5E;MAAEC,KAAO;MAAAC;IAAA,CAAW,GAAAH,OAAA;IAErB,KAAAI,OAAA,GAAU,CAAC,CAAG,KAAGF,KAAA,EAAO,CAAG,EAAAA,KAAA,EAAOC,MAAQ,KAAGA,MAAM;EAAA;EAC5D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAcOE,WAAWC,EAAA,EAAYC,EAAY,EAAAC,EAAA,EAAYC,EAAA,EAAYC,EAAY,EAAAC,EAAA,EAAYC,EAAA,EAAYC,EACtG;IACI,MAAMT,OAAA,GAAU,IAAK,CAAAA,OAAA;IAErBA,OAAA,CAAQ,CAAC,CAAI,GAAAE,EAAA;IACbF,OAAA,CAAQ,CAAC,CAAI,GAAAG,EAAA;IACbH,OAAA,CAAQ,CAAC,CAAI,GAAAI,EAAA;IACbJ,OAAA,CAAQ,CAAC,CAAI,GAAAK,EAAA;IACbL,OAAA,CAAQ,CAAC,CAAI,GAAAM,EAAA;IACbN,OAAA,CAAQ,CAAC,CAAI,GAAAO,EAAA;IACbP,OAAA,CAAQ,CAAC,CAAI,GAAAQ,EAAA;IACbR,OAAA,CAAQ,CAAC,CAAI,GAAAS,EAAA;IAEb,KAAKC,gBAAiB;EAAA;EAC1B;EAGOA,gBACPA,CAAA;IACU;MAAEZ,KAAO;MAAAC;IAAA,CAAW;IAC1B,MAAMC,OAAA,GAAU,IAAK,CAAAA,OAAA;IAErB,MAAMW,gBAAmB,GAAAC,mBAAA,CACrB,IAAK,CAAAf,iBAAA,EACL,GAAG;IAAA;IACHG,OAAA,CAAQ,CAAC,GAAGA,OAAA,CAAQ,CAAC;IAAA;IACrBF,KAAA,EAAO;IAAA;IACPE,OAAA,CAAQ,CAAC,GAAGA,OAAA,CAAQ,CAAC;IAAA;IACrBF,KAAA,EAAOC,MAAA;IAAA;IACPC,OAAA,CAAQ,CAAC,GAAGA,OAAA,CAAQ,CAAC;IAAA;IACrB,GAAGD,MAAA;IAAA;IACHC,OAAA,CAAQ,CAAC,GAAGA,OAAA,CAAQ,CAAC;IAAA;IAAA,CACzB;IAEAa,oCAAA,CACIf,KAAA,EACAC,MAAA,EACA,MACAY,gBAAA,CACJ;EAAA;AAER","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}