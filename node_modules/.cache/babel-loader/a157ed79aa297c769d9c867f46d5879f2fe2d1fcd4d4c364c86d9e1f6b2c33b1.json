{"ast":null,"code":"import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../maths/matrix/Matrix.mjs';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup.mjs';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform.mjs';\nimport { BatchableMesh } from './BatchableMesh.mjs';\n\"use strict\";\nclass MeshPipe {\n  constructor(renderer, adaptor) {\n    this.localUniforms = new UniformGroup({\n      uTransformMatrix: {\n        value: new Matrix(),\n        type: \"mat3x3<f32>\"\n      },\n      uColor: {\n        value: new Float32Array([1, 1, 1, 1]),\n        type: \"vec4<f32>\"\n      },\n      uRound: {\n        value: 0,\n        type: \"f32\"\n      }\n    });\n    this.localUniformsBindGroup = new BindGroup({\n      0: this.localUniforms\n    });\n    this._meshDataHash = /* @__PURE__ */Object.create(null);\n    this._gpuBatchableMeshHash = /* @__PURE__ */Object.create(null);\n    this._destroyRenderableBound = this.destroyRenderable.bind(this);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init();\n  }\n  validateRenderable(mesh) {\n    const meshData = this._getMeshData(mesh);\n    const wasBatched = meshData.batched;\n    const isBatched = mesh.batched;\n    meshData.batched = isBatched;\n    if (wasBatched !== isBatched) {\n      return true;\n    } else if (isBatched) {\n      const geometry = mesh._geometry;\n      if (geometry.indices.length !== meshData.indexSize || geometry.positions.length !== meshData.vertexSize) {\n        meshData.indexSize = geometry.indices.length;\n        meshData.vertexSize = geometry.positions.length;\n        return true;\n      }\n      const batchableMesh = this._getBatchableMesh(mesh);\n      const texture = mesh.texture;\n      if (batchableMesh.texture._source !== texture._source) {\n        if (batchableMesh.texture._source !== texture._source) {\n          return !batchableMesh._batcher.checkAndUpdateTexture(batchableMesh, texture);\n        }\n      }\n    }\n    return false;\n  }\n  addRenderable(mesh, instructionSet) {\n    const batcher = this.renderer.renderPipes.batch;\n    const {\n      batched\n    } = this._getMeshData(mesh);\n    if (batched) {\n      const gpuBatchableMesh = this._getBatchableMesh(mesh);\n      gpuBatchableMesh.texture = mesh._texture;\n      gpuBatchableMesh.geometry = mesh._geometry;\n      batcher.addToBatch(gpuBatchableMesh, instructionSet);\n    } else {\n      batcher.break(instructionSet);\n      instructionSet.add(mesh);\n    }\n  }\n  updateRenderable(mesh) {\n    if (mesh.batched) {\n      const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n      gpuBatchableMesh.texture = mesh._texture;\n      gpuBatchableMesh.geometry = mesh._geometry;\n      gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);\n    }\n  }\n  destroyRenderable(mesh) {\n    this._meshDataHash[mesh.uid] = null;\n    const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n    if (gpuMesh) {\n      BigPool.return(gpuMesh);\n      this._gpuBatchableMeshHash[mesh.uid] = null;\n    }\n    mesh.off(\"destroyed\", this._destroyRenderableBound);\n  }\n  execute(mesh) {\n    if (!mesh.isRenderable) return;\n    mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);\n    const localUniforms = this.localUniforms;\n    localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n    localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n    localUniforms.update();\n    color32BitToUniform(mesh.groupColorAlpha, localUniforms.uniforms.uColor, 0);\n    this._adaptor.execute(this, mesh);\n  }\n  _getMeshData(mesh) {\n    return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n  }\n  _initMeshData(mesh) {\n    this._meshDataHash[mesh.uid] = {\n      batched: mesh.batched,\n      indexSize: mesh._geometry.indices?.length,\n      vertexSize: mesh._geometry.positions?.length\n    };\n    mesh.on(\"destroyed\", this._destroyRenderableBound);\n    return this._meshDataHash[mesh.uid];\n  }\n  _getBatchableMesh(mesh) {\n    return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n  }\n  _initBatchableMesh(mesh) {\n    const gpuMesh = BigPool.get(BatchableMesh);\n    gpuMesh.renderable = mesh;\n    gpuMesh.texture = mesh._texture;\n    gpuMesh.transform = mesh.groupTransform;\n    gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;\n    this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n    return gpuMesh;\n  }\n  destroy() {\n    for (const i in this._gpuBatchableMeshHash) {\n      if (this._gpuBatchableMeshHash[i]) {\n        BigPool.return(this._gpuBatchableMeshHash[i]);\n      }\n    }\n    this._gpuBatchableMeshHash = null;\n    this._meshDataHash = null;\n    this.localUniforms = null;\n    this.localUniformsBindGroup = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    this.renderer = null;\n  }\n}\n/** @ignore */\nMeshPipe.extension = {\n  type: [ExtensionType.WebGLPipes, ExtensionType.WebGPUPipes, ExtensionType.CanvasPipes],\n  name: \"mesh\"\n};\nexport { MeshPipe };","map":{"version":3,"names":["MeshPipe","constructor","renderer","adaptor","localUniforms","UniformGroup","uTransformMatrix","value","Matrix","type","uColor","Float32Array","uRound","localUniformsBindGroup","BindGroup","_meshDataHash","Object","create","_gpuBatchableMeshHash","_destroyRenderableBound","destroyRenderable","bind","_adaptor","init","validateRenderable","mesh","meshData","_getMeshData","wasBatched","batched","isBatched","geometry","_geometry","indices","length","indexSize","positions","vertexSize","batchableMesh","_getBatchableMesh","texture","_source","_batcher","checkAndUpdateTexture","addRenderable","instructionSet","batcher","renderPipes","batch","gpuBatchableMesh","_texture","addToBatch","break","add","updateRenderable","uid","updateElement","gpuMesh","BigPool","return","off","execute","isRenderable","state","blendMode","getAdjustedBlendModeBlend","groupBlendMode","uniforms","groupTransform","_roundPixels","update","color32BitToUniform","groupColorAlpha","_initMeshData","on","_initBatchableMesh","get","BatchableMesh","renderable","transform","roundPixels","destroy","i","extension","ExtensionType","WebGLPipes","WebGPUPipes","CanvasPipes","name"],"sources":["/workspaces/royal-games-updated/node_modules/pixi.js/src/scene/mesh/shared/MeshPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from './BatchableMesh';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type {\n    InstructionPipe,\n    RenderPipe\n} from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Container } from '../../container/Container';\nimport type { Mesh } from './Mesh';\n\n// TODO Record mode is a P2, will get back to this as it's not a priority\n// const recordMode = true;\n\ninterface MeshData\n{\n    batched: boolean;\n    indexSize: number;\n    vertexSize: number;\n}\n\nexport interface MeshAdaptor\n{\n    init(): void;\n    execute(meshPipe: MeshPipe, mesh: Mesh): void;\n    destroy(): void;\n}\n\n// eslint-disable-next-line max-len\nexport class MeshPipe implements RenderPipe<Mesh>, InstructionPipe<Mesh>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'mesh',\n    } as const;\n\n    public localUniforms = new UniformGroup({\n        uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n        uRound: { value: 0, type: 'f32' },\n    });\n\n    public localUniformsBindGroup = new BindGroup({\n        0: this.localUniforms,\n    });\n\n    public renderer: Renderer;\n\n    private _meshDataHash: Record<number, MeshData> = Object.create(null);\n    private _gpuBatchableMeshHash: Record<number, BatchableMesh> = Object.create(null);\n    private _adaptor: MeshAdaptor;\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer, adaptor: MeshAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init();\n    }\n\n    public validateRenderable(mesh: Mesh): boolean\n    {\n        const meshData = this._getMeshData(mesh);\n\n        const wasBatched = meshData.batched;\n\n        const isBatched = mesh.batched;\n\n        meshData.batched = isBatched;\n\n        if (wasBatched !== isBatched)\n        {\n            return true;\n        }\n        else if (isBatched)\n        {\n            const geometry = mesh._geometry;\n\n            // no need to break the batch if it's the same size\n            if (geometry.indices.length !== meshData.indexSize\n                    || geometry.positions.length !== meshData.vertexSize)\n            {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n\n                return true;\n            }\n\n            const batchableMesh = this._getBatchableMesh(mesh);\n\n            const texture = mesh.texture;\n\n            if (batchableMesh.texture._source !== texture._source)\n            {\n                if (batchableMesh.texture._source !== texture._source)\n                {\n                    return !batchableMesh._batcher.checkAndUpdateTexture(batchableMesh, texture);\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public addRenderable(mesh: Mesh, instructionSet: InstructionSet)\n    {\n        const batcher = this.renderer.renderPipes.batch;\n\n        const { batched } = this._getMeshData(mesh);\n\n        if (batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            batcher.addToBatch(gpuBatchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            instructionSet.add(mesh);\n        }\n    }\n\n    public updateRenderable(mesh: Mesh)\n    {\n        if (mesh.batched)\n        {\n            const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n            gpuBatchableMesh.texture = mesh._texture;\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n\n    public destroyRenderable(mesh: Mesh)\n    {\n        this._meshDataHash[mesh.uid] = null;\n\n        const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n        if (gpuMesh)\n        {\n            BigPool.return(gpuMesh as PoolItem);\n            this._gpuBatchableMeshHash[mesh.uid] = null;\n        }\n\n        mesh.off('destroyed', this._destroyRenderableBound);\n    }\n\n    public execute(mesh: Mesh)\n    {\n        if (!mesh.isRenderable) return;\n\n        mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);\n\n        const localUniforms = this.localUniforms;\n\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n\n        color32BitToUniform(\n            mesh.groupColorAlpha,\n            localUniforms.uniforms.uColor,\n            0\n        );\n\n        this._adaptor.execute(this, mesh);\n    }\n\n    private _getMeshData(mesh: Mesh): MeshData\n    {\n        return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n    }\n\n    private _initMeshData(mesh: Mesh): MeshData\n    {\n        this._meshDataHash[mesh.uid] = {\n            batched: mesh.batched,\n            indexSize: mesh._geometry.indices?.length,\n            vertexSize: mesh._geometry.positions?.length,\n        };\n\n        mesh.on('destroyed', this._destroyRenderableBound);\n\n        return this._meshDataHash[mesh.uid];\n    }\n\n    private _getBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n    }\n\n    private _initBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        // TODO - make this batchable graphics??\n        const gpuMesh: BatchableMesh = BigPool.get(BatchableMesh);\n\n        gpuMesh.renderable = mesh;\n        gpuMesh.texture = mesh._texture;\n        gpuMesh.transform = mesh.groupTransform;\n        gpuMesh.roundPixels = (this.renderer._roundPixels | mesh._roundPixels) as 0 | 1;\n\n        this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n\n        return gpuMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuBatchableMeshHash)\n        {\n            if (this._gpuBatchableMeshHash[i])\n            {\n                BigPool.return(this._gpuBatchableMeshHash[i] as PoolItem);\n            }\n        }\n\n        this._gpuBatchableMeshHash = null;\n        this._meshDataHash = null;\n\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n\n        this.renderer = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}