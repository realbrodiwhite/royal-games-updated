{"ast":null,"code":"import { LoaderParserPriority } from '../../../assets/loader/parsers/LoaderParser.mjs';\nimport { copySearchParams } from '../../../assets/utils/copySearchParams.mjs';\nimport { DOMAdapter } from '../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { path } from '../../../utils/path.mjs';\nimport { BitmapFont } from '../BitmapFont.mjs';\nimport { bitmapFontTextParser } from './bitmapFontTextParser.mjs';\nimport { bitmapFontXMLStringParser } from './bitmapFontXMLStringParser.mjs';\n\"use strict\";\nconst validExtensions = [\".xml\", \".fnt\"];\nconst bitmapFontCachePlugin = {\n  extension: {\n    type: ExtensionType.CacheParser,\n    name: \"cacheBitmapFont\"\n  },\n  test: asset => asset instanceof BitmapFont,\n  getCacheableAssets(keys, asset) {\n    const out = {};\n    keys.forEach(key => {\n      out[key] = asset;\n      out[`${key}-bitmap`] = asset;\n    });\n    out[`${asset.fontFamily}-bitmap`] = asset;\n    return out;\n  }\n};\nconst loadBitmapFont = {\n  extension: {\n    type: ExtensionType.LoadParser,\n    priority: LoaderParserPriority.Normal\n  },\n  name: \"loadBitmapFont\",\n  test(url) {\n    return validExtensions.includes(path.extname(url).toLowerCase());\n  },\n  async testParse(data) {\n    return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);\n  },\n  async parse(asset, data, loader) {\n    const bitmapFontData = bitmapFontTextParser.test(asset) ? bitmapFontTextParser.parse(asset) : bitmapFontXMLStringParser.parse(asset);\n    const {\n      src\n    } = data;\n    const {\n      pages\n    } = bitmapFontData;\n    const textureUrls = [];\n    const textureOptions = bitmapFontData.distanceField ? {\n      scaleMode: \"linear\",\n      alphaMode: \"premultiply-alpha-on-upload\",\n      autoGenerateMipmaps: false,\n      resolution: 1\n    } : {};\n    for (let i = 0; i < pages.length; ++i) {\n      const pageFile = pages[i].file;\n      let imagePath = path.join(path.dirname(src), pageFile);\n      imagePath = copySearchParams(imagePath, src);\n      textureUrls.push({\n        src: imagePath,\n        data: textureOptions\n      });\n    }\n    const loadedTextures = await loader.load(textureUrls);\n    const textures = textureUrls.map(url => loadedTextures[url.src]);\n    const bitmapFont = new BitmapFont({\n      data: bitmapFontData,\n      textures\n    }, src);\n    return bitmapFont;\n  },\n  async load(url, _options) {\n    const response = await DOMAdapter.get().fetch(url);\n    return await response.text();\n  },\n  async unload(bitmapFont, _resolvedAsset, loader) {\n    await Promise.all(bitmapFont.pages.map(page => loader.unload(page.texture.source._sourceOrigin)));\n    bitmapFont.destroy();\n  }\n};\nexport { bitmapFontCachePlugin, loadBitmapFont };","map":{"version":3,"names":["validExtensions","bitmapFontCachePlugin","extension","type","ExtensionType","CacheParser","name","test","asset","BitmapFont","getCacheableAssets","keys","out","forEach","key","fontFamily","loadBitmapFont","LoadParser","priority","LoaderParserPriority","Normal","url","includes","path","extname","toLowerCase","testParse","data","bitmapFontTextParser","bitmapFontXMLStringParser","parse","loader","bitmapFontData","src","pages","textureUrls","textureOptions","distanceField","scaleMode","alphaMode","autoGenerateMipmaps","resolution","i","length","pageFile","file","imagePath","join","dirname","copySearchParams","push","loadedTextures","load","textures","map","bitmapFont","_options","response","DOMAdapter","get","fetch","text","unload","_resolvedAsset","Promise","all","page","texture","source","_sourceOrigin","destroy"],"sources":["/workspaces/royal-games-updated/node_modules/pixi.js/src/scene/text-bitmap/asset/loadBitmapFont.ts"],"sourcesContent":["import { LoaderParserPriority } from '../../../assets/loader/parsers/LoaderParser';\nimport { copySearchParams } from '../../../assets/utils/copySearchParams';\nimport { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { path } from '../../../utils/path';\nimport { BitmapFont } from '../BitmapFont';\nimport { bitmapFontTextParser } from './bitmapFontTextParser';\nimport { bitmapFontXMLStringParser } from './bitmapFontXMLStringParser';\n\nimport type { CacheParser } from '../../../assets/cache/CacheParser';\nimport type { Loader } from '../../../assets/loader/Loader';\nimport type { LoaderParserAdvanced } from '../../../assets/loader/parsers/LoaderParser';\nimport type { ResolvedAsset } from '../../../assets/types';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst validExtensions = ['.xml', '.fnt'];\n\n/** simple loader plugin for loading in bitmap fonts! */\nexport const bitmapFontCachePlugin = {\n    extension: {\n        type: ExtensionType.CacheParser,\n        name: 'cacheBitmapFont',\n    },\n    test: (asset: BitmapFont) => asset instanceof BitmapFont,\n    getCacheableAssets(keys: string[], asset: BitmapFont)\n    {\n        const out: Record<string, BitmapFont> = {};\n\n        keys.forEach((key) =>\n        {\n            out[key] = asset;\n            out[`${key}-bitmap`] = asset;\n        });\n\n        out[`${asset.fontFamily}-bitmap`] = asset;\n\n        return out;\n    }\n} satisfies CacheParser<BitmapFont>;\n\nexport const loadBitmapFont = {\n    extension: {\n        type: ExtensionType.LoadParser,\n        priority: LoaderParserPriority.Normal,\n    },\n\n    name: 'loadBitmapFont',\n\n    test(url: string): boolean\n    {\n        return validExtensions.includes(path.extname(url).toLowerCase());\n    },\n\n    async testParse(data: string): Promise<boolean>\n    {\n        return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);\n    },\n\n    async parse(asset: string, data: ResolvedAsset, loader: Loader): Promise<BitmapFont>\n    {\n        const bitmapFontData = bitmapFontTextParser.test(asset)\n            ? bitmapFontTextParser.parse(asset)\n            : bitmapFontXMLStringParser.parse(asset);\n\n        const { src } = data;\n        const { pages } = bitmapFontData;\n        const textureUrls = [];\n\n        // if we have a distance field - we can assume this is a signed distance field font\n        // and we should use force linear filtering and no alpha premultiply\n        const textureOptions = (bitmapFontData.distanceField) ? {\n            scaleMode: 'linear',\n            alphaMode: 'premultiply-alpha-on-upload',\n            autoGenerateMipmaps: false,\n            resolution: 1,\n        } : {};\n\n        for (let i = 0; i < pages.length; ++i)\n        {\n            const pageFile = pages[i].file;\n            let imagePath = path.join(path.dirname(src), pageFile);\n\n            imagePath = copySearchParams(imagePath, src);\n\n            textureUrls.push({\n                src: imagePath,\n                data: textureOptions\n            });\n        }\n\n        const loadedTextures = await loader.load<Texture>(textureUrls);\n        const textures = textureUrls.map((url) => loadedTextures[url.src]);\n\n        const bitmapFont = new BitmapFont({\n            data: bitmapFontData,\n            textures\n        }, src);\n\n        return bitmapFont;\n    },\n\n    async load(url: string, _options: ResolvedAsset): Promise<string>\n    {\n        const response = await DOMAdapter.get().fetch(url);\n\n        return await response.text();\n    },\n\n    async unload(bitmapFont: BitmapFont, _resolvedAsset, loader): Promise<void>\n    {\n        await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));\n\n        bitmapFont.destroy();\n    }\n} satisfies LoaderParserAdvanced<string, BitmapFont, BitmapFont>;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}