{"ast":null,"code":"import { pointInTriangle } from '../../../maths/point/pointInTriangle.mjs';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry.mjs';\nimport { State } from '../../../rendering/renderers/shared/state/State.mjs';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation.mjs';\nimport { ViewContainer } from '../../view/View.mjs';\nimport { MeshGeometry } from './MeshGeometry.mjs';\n\"use strict\";\nclass Mesh extends ViewContainer {\n  constructor() {\n    let options = arguments.length <= 0 ? undefined : arguments[0];\n    if (options instanceof Geometry) {\n      deprecation(v8_0_0, \"Mesh: use new Mesh({ geometry, shader }) instead\");\n      options = {\n        geometry: options,\n        shader: arguments.length <= 1 ? undefined : arguments[1]\n      };\n      if (arguments.length <= 3 ? undefined : arguments[3]) {\n        deprecation(v8_0_0, \"Mesh: drawMode argument has been removed, use geometry.topology instead\");\n        options.geometry.topology = arguments.length <= 3 ? undefined : arguments[3];\n      }\n    }\n    const {\n      geometry,\n      shader,\n      texture,\n      roundPixels,\n      state,\n      ...rest\n    } = options;\n    super({\n      label: \"Mesh\",\n      ...rest\n    });\n    this.renderPipeId = \"mesh\";\n    /** @ignore */\n    this._shader = null;\n    this.allowChildren = false;\n    this.shader = shader ?? null;\n    this.texture = texture ?? shader?.texture ?? Texture.WHITE;\n    this.state = state ?? State.for2d();\n    this._geometry = geometry;\n    this._geometry.on(\"update\", this.onViewUpdate, this);\n    this.roundPixels = roundPixels ?? false;\n  }\n  /** Alias for {@link scene.Mesh#shader}. */\n  get material() {\n    deprecation(v8_0_0, \"mesh.material property has been removed, use mesh.shader instead\");\n    return this._shader;\n  }\n  /**\n   * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n   * Can be shared between multiple Mesh objects.\n   */\n  set shader(value) {\n    if (this._shader === value) return;\n    this._shader = value;\n    this.onViewUpdate();\n  }\n  get shader() {\n    return this._shader;\n  }\n  /**\n   * Includes vertex positions, face indices, colors, UVs, and\n   * custom attributes within buffers, reducing the cost of passing all\n   * this data to the GPU. Can be shared between multiple Mesh objects.\n   */\n  set geometry(value) {\n    if (this._geometry === value) return;\n    this._geometry?.off(\"update\", this.onViewUpdate, this);\n    value.on(\"update\", this.onViewUpdate, this);\n    this._geometry = value;\n    this.onViewUpdate();\n  }\n  get geometry() {\n    return this._geometry;\n  }\n  /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n  set texture(value) {\n    value || (value = Texture.EMPTY);\n    const currentTexture = this._texture;\n    if (currentTexture === value) return;\n    if (currentTexture && currentTexture.dynamic) currentTexture.off(\"update\", this.onViewUpdate, this);\n    if (value.dynamic) value.on(\"update\", this.onViewUpdate, this);\n    if (this.shader) {\n      this.shader.texture = value;\n    }\n    this._texture = value;\n    this.onViewUpdate();\n  }\n  get texture() {\n    return this._texture;\n  }\n  get batched() {\n    if (this._shader) return false;\n    if ((this.state.data & 12) !== 0) return false;\n    if (this._geometry instanceof MeshGeometry) {\n      if (this._geometry.batchMode === \"auto\") {\n        return this._geometry.positions.length / 2 <= 100;\n      }\n      return this._geometry.batchMode === \"batch\";\n    }\n    return false;\n  }\n  /**\n   * The local bounds of the mesh.\n   * @type {rendering.Bounds}\n   */\n  get bounds() {\n    return this._geometry.bounds;\n  }\n  /**\n   * Adds the bounds of this object to the bounds object.\n   * @param bounds - The output bounds object.\n   */\n  addBounds(bounds) {\n    bounds.addBounds(this.geometry.bounds);\n  }\n  /**\n   * Checks if the object contains the given point.\n   * @param point - The point to check\n   */\n  containsPoint(point) {\n    const {\n      x,\n      y\n    } = point;\n    if (!this.bounds.containsPoint(x, y)) return false;\n    const vertices = this.geometry.getBuffer(\"aPosition\").data;\n    const step = this.geometry.topology === \"triangle-strip\" ? 3 : 1;\n    if (this.geometry.getIndex()) {\n      const indices = this.geometry.getIndex().data;\n      const len = indices.length;\n      for (let i = 0; i + 2 < len; i += step) {\n        const ind0 = indices[i] * 2;\n        const ind1 = indices[i + 1] * 2;\n        const ind2 = indices[i + 2] * 2;\n        if (pointInTriangle(x, y, vertices[ind0], vertices[ind0 + 1], vertices[ind1], vertices[ind1 + 1], vertices[ind2], vertices[ind2 + 1])) {\n          return true;\n        }\n      }\n    } else {\n      const len = vertices.length / 2;\n      for (let i = 0; i + 2 < len; i += step) {\n        const ind0 = i * 2;\n        const ind1 = (i + 1) * 2;\n        const ind2 = (i + 2) * 2;\n        if (pointInTriangle(x, y, vertices[ind0], vertices[ind0 + 1], vertices[ind1], vertices[ind1 + 1], vertices[ind2], vertices[ind2 + 1])) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  /** @ignore */\n  onViewUpdate() {\n    this._didViewChangeTick++;\n    if (this.didViewUpdate) return;\n    this.didViewUpdate = true;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.onChildViewUpdate(this);\n    }\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n   */\n  destroy(options) {\n    super.destroy(options);\n    const destroyTexture = typeof options === \"boolean\" ? options : options?.texture;\n    if (destroyTexture) {\n      const destroyTextureSource = typeof options === \"boolean\" ? options : options?.textureSource;\n      this._texture.destroy(destroyTextureSource);\n    }\n    this._geometry?.off(\"update\", this.onViewUpdate, this);\n    this._texture = null;\n    this._geometry = null;\n    this._shader = null;\n  }\n}\nexport { Mesh };","map":{"version":3,"names":["Mesh","ViewContainer","constructor","options","arguments","length","undefined","Geometry","deprecation","v8_0_0","geometry","shader","topology","texture","roundPixels","state","rest","label","renderPipeId","_shader","allowChildren","Texture","WHITE","State","for2d","_geometry","on","onViewUpdate","material","value","off","EMPTY","currentTexture","_texture","dynamic","batched","data","MeshGeometry","batchMode","positions","bounds","addBounds","containsPoint","point","x","y","vertices","getBuffer","step","getIndex","indices","len","i","ind0","ind1","ind2","pointInTriangle","_didViewChangeTick","didViewUpdate","renderGroup","parentRenderGroup","onChildViewUpdate","destroy","destroyTexture","destroyTextureSource","textureSource"],"sources":["/workspaces/royal-games-updated/node_modules/pixi.js/src/scene/mesh/shared/Mesh.ts"],"sourcesContent":["import { pointInTriangle } from '../../../maths/point/pointInTriangle';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { ViewContainer } from '../../view/View';\nimport { MeshGeometry } from './MeshGeometry';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { View } from '../../../rendering/renderers/shared/view/View';\nimport type { Bounds } from '../../container/bounds/Bounds';\nimport type { ContainerOptions } from '../../container/Container';\nimport type { DestroyOptions } from '../../container/destroyTypes';\n\nexport interface TextureShader extends Shader\n{\n    texture: Texture;\n}\n\n/**\n * Constructor options used for `Mesh` instances. Extends {@link scene.MeshViewOptions}\n * ```js\n * const mesh = new Mesh({\n *    texture: Texture.from('assets/image.png'),\n *    geometry: new PlaneGeometry(),\n *    shader: Shader.from(VERTEX, FRAGMENT),\n * });\n * ```\n * @see {@link scene.Mesh}\n * @see {@link scene.MeshViewOptions}\n * @memberof scene\n */\n\n/**\n * @memberof scene\n */\nexport interface MeshOptions<\n    GEOMETRY extends Geometry = MeshGeometry,\n    SHADER extends Shader = TextureShader\n> extends ContainerOptions\n{\n    /**\n     * Includes vertex positions, face indices, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh objects.\n     */\n    geometry: GEOMETRY;\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Mesh objects.\n     */\n    shader?: SHADER | null;\n    /** The state of WebGL required to render the mesh. */\n    state?: State;\n    /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n    texture?: Texture;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n/**\n * Base mesh class.\n *\n * This class empowers you to have maximum flexibility to render any kind of WebGL/WebGPU visuals you can think of.\n * This class assumes a certain level of WebGL/WebGPU knowledge.\n * If you know a bit this should abstract enough away to make your life easier!\n *\n * Pretty much ALL WebGL/WebGPU can be broken down into the following:\n * - Geometry - The structure and data for the mesh. This can include anything from positions, uvs, normals, colors etc..\n * - Shader - This is the shader that PixiJS will render the geometry with (attributes in the shader must match the geometry)\n * - State - This is the state of WebGL required to render the mesh.\n *\n * Through a combination of the above elements you can render anything you want, 2D or 3D!\n * @memberof scene\n */\nexport class Mesh<\n    GEOMETRY extends Geometry = MeshGeometry,\n    SHADER extends Shader = TextureShader\n> extends ViewContainer implements View, Instruction\n{\n    public override readonly renderPipeId: string = 'mesh';\n    public state: State;\n\n    /** @ignore */\n    public _texture: Texture;\n    /** @ignore */\n    public _geometry: GEOMETRY;\n    /** @ignore */\n    public _shader: SHADER | null = null;\n\n    /**\n     * @param {scene.MeshOptions} options - options for the mesh instance\n     */\n    constructor(options: MeshOptions<GEOMETRY, SHADER>);\n    /** @deprecated since 8.0.0 */\n    constructor(geometry: GEOMETRY, shader: SHADER, state?: State, drawMode?: Topology);\n    constructor(...args: [MeshOptions<GEOMETRY, SHADER>] | [GEOMETRY, SHADER, State?, Topology?])\n    {\n        let options = args[0];\n\n        if (options instanceof Geometry)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'Mesh: use new Mesh({ geometry, shader }) instead');\n            // #endif\n\n            options = {\n                geometry: options,\n                shader: args[1],\n            } as MeshOptions<GEOMETRY, SHADER>;\n\n            if (args[3])\n            {\n                // #if _DEBUG\n                deprecation(v8_0_0, 'Mesh: drawMode argument has been removed, use geometry.topology instead');\n                // #endif\n\n                options.geometry.topology = args[3];\n            }\n        }\n\n        const { geometry, shader, texture, roundPixels, state, ...rest } = options;\n\n        super({\n            label: 'Mesh',\n            ...rest\n        });\n\n        this.allowChildren = false;\n\n        this.shader = shader ?? null;\n        this.texture = texture ?? (shader as unknown as TextureShader)?.texture ?? Texture.WHITE;\n        this.state = state ?? State.for2d();\n\n        this._geometry = geometry;\n        this._geometry.on('update', this.onViewUpdate, this);\n\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    /** Alias for {@link scene.Mesh#shader}. */\n    get material()\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'mesh.material property has been removed, use mesh.shader instead');\n        // #endif\n\n        return this._shader;\n    }\n\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Mesh objects.\n     */\n    set shader(value: SHADER | null)\n    {\n        if (this._shader === value) return;\n\n        this._shader = value;\n        this.onViewUpdate();\n    }\n\n    get shader(): SHADER | null\n    {\n        return this._shader;\n    }\n\n    /**\n     * Includes vertex positions, face indices, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh objects.\n     */\n    set geometry(value: GEOMETRY)\n    {\n        if (this._geometry === value) return;\n\n        this._geometry?.off('update', this.onViewUpdate, this);\n        value.on('update', this.onViewUpdate, this);\n\n        this._geometry = value;\n        this.onViewUpdate();\n    }\n\n    get geometry()\n    {\n        return this._geometry;\n    }\n\n    /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        const currentTexture = this._texture;\n\n        if (currentTexture === value) return;\n\n        if (currentTexture && currentTexture.dynamic) currentTexture.off('update', this.onViewUpdate, this);\n        if (value.dynamic) value.on('update', this.onViewUpdate, this);\n\n        if (this.shader)\n        {\n            (this.shader as unknown as TextureShader).texture = value;\n        }\n\n        this._texture = value;\n        this.onViewUpdate();\n    }\n\n    get texture()\n    {\n        return this._texture;\n    }\n\n    get batched()\n    {\n        if (this._shader) return false;\n\n        // The state must be compatible with the batcher pipe.\n        // It isn't compatible if depth test or culling is enabled.\n        if ((this.state.data & 0b001100) !== 0) return false;\n\n        if (this._geometry instanceof MeshGeometry)\n        {\n            if (this._geometry.batchMode === 'auto')\n            {\n                return this._geometry.positions.length / 2 <= 100;\n            }\n\n            return this._geometry.batchMode === 'batch';\n        }\n\n        return false;\n    }\n\n    /**\n     * The local bounds of the mesh.\n     * @type {rendering.Bounds}\n     */\n    override get bounds()\n    {\n        return this._geometry.bounds;\n    }\n\n    /**\n     * Adds the bounds of this object to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        bounds.addBounds(this.geometry.bounds);\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public override containsPoint(point: PointData)\n    {\n        const { x, y } = point;\n\n        if (!this.bounds.containsPoint(x, y)) return false;\n\n        const vertices = this.geometry.getBuffer('aPosition').data;\n\n        const step = this.geometry.topology === 'triangle-strip' ? 3 : 1;\n\n        if (this.geometry.getIndex())\n        {\n            const indices = this.geometry.getIndex().data;\n            const len = indices.length;\n\n            for (let i = 0; i + 2 < len; i += step)\n            {\n                const ind0 = indices[i] * 2;\n                const ind1 = indices[i + 1] * 2;\n                const ind2 = indices[i + 2] * 2;\n\n                if (pointInTriangle(\n                    x, y,\n                    vertices[ind0],\n                    vertices[ind0 + 1],\n                    vertices[ind1],\n                    vertices[ind1 + 1],\n                    vertices[ind2],\n                    vertices[ind2 + 1],\n                ))\n                {\n                    return true;\n                }\n            }\n        }\n        else\n        {\n            const len = vertices.length / 2; // Each vertex has 2 coordinates, x and y\n\n            for (let i = 0; i + 2 < len; i += step)\n            {\n                const ind0 = i * 2;\n                const ind1 = (i + 1) * 2;\n                const ind2 = (i + 2) * 2;\n\n                if (pointInTriangle(\n                    x, y,\n                    vertices[ind0],\n                    vertices[ind0 + 1],\n                    vertices[ind1],\n                    vertices[ind1 + 1],\n                    vertices[ind2],\n                    vertices[ind2 + 1],\n                ))\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /** @ignore */\n    public onViewUpdate()\n    {\n        this._didViewChangeTick++;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public override destroy(options?: DestroyOptions): void\n    {\n        super.destroy(options);\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._geometry?.off('update', this.onViewUpdate, this);\n\n        this._texture = null;\n        this._geometry = null;\n        this._shader = null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}