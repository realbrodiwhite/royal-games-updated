{"ast":null,"code":"import { uid } from '../../../utils/data/uid.mjs';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer.mjs';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy.mjs';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures.mjs';\nimport { BatchTextureArray } from './BatchTextureArray.mjs';\n\"use strict\";\nclass Batch {\n  constructor() {\n    this.renderPipeId = \"batch\";\n    this.action = \"startBatch\";\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n    // for drawing..\n    this.start = 0;\n    this.size = 0;\n    this.textures = new BatchTextureArray();\n    this.blendMode = \"normal\";\n    this.canBundle = true;\n  }\n  destroy() {\n    this.textures = null;\n    this.gpuBindGroup = null;\n    this.bindGroup = null;\n    this.batcher = null;\n  }\n}\nconst batchPool = [];\nlet batchPoolIndex = 0;\nfunction getBatchFromPool() {\n  return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();\n}\nfunction returnBatchToPool(batch) {\n  batchPool[batchPoolIndex++] = batch;\n}\nlet BATCH_TICK = 0;\nconst _Batcher = class _Batcher {\n  constructor(options = {}) {\n    /** unique id for this batcher */\n    this.uid = uid(\"batcher\");\n    /** Indicates whether the batch data has been modified and needs updating. */\n    this.dirty = true;\n    /** The current index of the batch being processed. */\n    this.batchIndex = 0;\n    /** An array of all batches created during the current rendering process. */\n    this.batches = [];\n    this._elements = [];\n    _Batcher.defaultOptions.maxTextures = _Batcher.defaultOptions.maxTextures ?? getMaxTexturesPerBatch();\n    options = {\n      ..._Batcher.defaultOptions,\n      ...options\n    };\n    const {\n      maxTextures,\n      attributesInitialSize,\n      indicesInitialSize\n    } = options;\n    this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);\n    this.indexBuffer = new Uint16Array(indicesInitialSize);\n    this.maxTextures = maxTextures;\n  }\n  begin() {\n    this.elementSize = 0;\n    this.elementStart = 0;\n    this.indexSize = 0;\n    this.attributeSize = 0;\n    for (let i = 0; i < this.batchIndex; i++) {\n      returnBatchToPool(this.batches[i]);\n    }\n    this.batchIndex = 0;\n    this._batchIndexStart = 0;\n    this._batchIndexSize = 0;\n    this.dirty = true;\n  }\n  add(batchableObject) {\n    this._elements[this.elementSize++] = batchableObject;\n    batchableObject._indexStart = this.indexSize;\n    batchableObject._attributeStart = this.attributeSize;\n    batchableObject._batcher = this;\n    this.indexSize += batchableObject.indexSize;\n    this.attributeSize += batchableObject.attributeSize * this.vertexSize;\n  }\n  checkAndUpdateTexture(batchableObject, texture) {\n    const textureId = batchableObject._batch.textures.ids[texture._source.uid];\n    if (!textureId && textureId !== 0) return false;\n    batchableObject._textureId = textureId;\n    batchableObject.texture = texture;\n    return true;\n  }\n  updateElement(batchableObject) {\n    this.dirty = true;\n    const attributeBuffer = this.attributeBuffer;\n    if (batchableObject.packAsQuad) {\n      this.packQuadAttributes(batchableObject, attributeBuffer.float32View, attributeBuffer.uint32View, batchableObject._attributeStart, batchableObject._textureId);\n    } else {\n      this.packAttributes(batchableObject, attributeBuffer.float32View, attributeBuffer.uint32View, batchableObject._attributeStart, batchableObject._textureId);\n    }\n  }\n  /**\n   * breaks the batcher. This happens when a batch gets too big,\n   * or we need to switch to a different type of rendering (a filter for example)\n   * @param instructionSet\n   */\n  break(instructionSet) {\n    const elements = this._elements;\n    if (!elements[this.elementStart]) return;\n    let batch = getBatchFromPool();\n    let textureBatch = batch.textures;\n    textureBatch.clear();\n    const firstElement = elements[this.elementStart];\n    let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n    if (this.attributeSize * 4 > this.attributeBuffer.size) {\n      this._resizeAttributeBuffer(this.attributeSize * 4);\n    }\n    if (this.indexSize > this.indexBuffer.length) {\n      this._resizeIndexBuffer(this.indexSize);\n    }\n    const f32 = this.attributeBuffer.float32View;\n    const u32 = this.attributeBuffer.uint32View;\n    const indexBuffer = this.indexBuffer;\n    let size = this._batchIndexSize;\n    let start = this._batchIndexStart;\n    let action = \"startBatch\";\n    const maxTextures = this.maxTextures;\n    for (let i = this.elementStart; i < this.elementSize; ++i) {\n      const element = elements[i];\n      elements[i] = null;\n      const texture = element.texture;\n      const source = texture._source;\n      const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n      const breakRequired = blendMode !== adjustedBlendMode;\n      if (source._batchTick === BATCH_TICK && !breakRequired) {\n        element._textureId = source._textureBindLocation;\n        size += element.indexSize;\n        if (element.packAsQuad) {\n          this.packQuadAttributes(element, f32, u32, element._attributeStart, element._textureId);\n          this.packQuadIndex(indexBuffer, element._indexStart, element._attributeStart / this.vertexSize);\n        } else {\n          this.packAttributes(element, f32, u32, element._attributeStart, element._textureId);\n          this.packIndex(element, indexBuffer, element._indexStart, element._attributeStart / this.vertexSize);\n        }\n        element._batch = batch;\n        continue;\n      }\n      source._batchTick = BATCH_TICK;\n      if (textureBatch.count >= maxTextures || breakRequired) {\n        this._finishBatch(batch, start, size - start, textureBatch, blendMode, instructionSet, action);\n        action = \"renderBatch\";\n        start = size;\n        blendMode = adjustedBlendMode;\n        batch = getBatchFromPool();\n        textureBatch = batch.textures;\n        textureBatch.clear();\n        ++BATCH_TICK;\n      }\n      element._textureId = source._textureBindLocation = textureBatch.count;\n      textureBatch.ids[source.uid] = textureBatch.count;\n      textureBatch.textures[textureBatch.count++] = source;\n      element._batch = batch;\n      size += element.indexSize;\n      if (element.packAsQuad) {\n        this.packQuadAttributes(element, f32, u32, element._attributeStart, element._textureId);\n        this.packQuadIndex(indexBuffer, element._indexStart, element._attributeStart / this.vertexSize);\n      } else {\n        this.packAttributes(element, f32, u32, element._attributeStart, element._textureId);\n        this.packIndex(element, indexBuffer, element._indexStart, element._attributeStart / this.vertexSize);\n      }\n    }\n    if (textureBatch.count > 0) {\n      this._finishBatch(batch, start, size - start, textureBatch, blendMode, instructionSet, action);\n      start = size;\n      ++BATCH_TICK;\n    }\n    this.elementStart = this.elementSize;\n    this._batchIndexStart = start;\n    this._batchIndexSize = size;\n  }\n  _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, instructionSet, action) {\n    batch.gpuBindGroup = null;\n    batch.bindGroup = null;\n    batch.action = action;\n    batch.batcher = this;\n    batch.textures = textureBatch;\n    batch.blendMode = blendMode;\n    batch.start = indexStart;\n    batch.size = indexSize;\n    ++BATCH_TICK;\n    this.batches[this.batchIndex++] = batch;\n    instructionSet.add(batch);\n  }\n  finish(instructionSet) {\n    this.break(instructionSet);\n  }\n  /**\n   * Resizes the attribute buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureAttributeBuffer(size) {\n    if (size * 4 <= this.attributeBuffer.size) return;\n    this._resizeAttributeBuffer(size * 4);\n  }\n  /**\n   * Resizes the index buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureIndexBuffer(size) {\n    if (size <= this.indexBuffer.length) return;\n    this._resizeIndexBuffer(size);\n  }\n  _resizeAttributeBuffer(size) {\n    const newSize = Math.max(size, this.attributeBuffer.size * 2);\n    const newArrayBuffer = new ViewableBuffer(newSize);\n    fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n    this.attributeBuffer = newArrayBuffer;\n  }\n  _resizeIndexBuffer(size) {\n    const indexBuffer = this.indexBuffer;\n    let newSize = Math.max(size, indexBuffer.length * 1.5);\n    newSize += newSize % 2;\n    const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);\n    if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {\n      for (let i = 0; i < indexBuffer.length; i++) {\n        newIndexBuffer[i] = indexBuffer[i];\n      }\n    } else {\n      fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n    }\n    this.indexBuffer = newIndexBuffer;\n  }\n  packQuadIndex(indexBuffer, index, indicesOffset) {\n    indexBuffer[index] = indicesOffset + 0;\n    indexBuffer[index + 1] = indicesOffset + 1;\n    indexBuffer[index + 2] = indicesOffset + 2;\n    indexBuffer[index + 3] = indicesOffset + 0;\n    indexBuffer[index + 4] = indicesOffset + 2;\n    indexBuffer[index + 5] = indicesOffset + 3;\n  }\n  packIndex(element, indexBuffer, index, indicesOffset) {\n    const indices = element.indices;\n    const size = element.indexSize;\n    const indexOffset = element.indexOffset;\n    const attributeOffset = element.attributeOffset;\n    for (let i = 0; i < size; i++) {\n      indexBuffer[index++] = indicesOffset + indices[i + indexOffset] - attributeOffset;\n    }\n  }\n  destroy() {\n    for (let i = 0; i < this.batches.length; i++) {\n      returnBatchToPool(this.batches[i]);\n    }\n    this.batches = null;\n    for (let i = 0; i < this._elements.length; i++) {\n      this._elements[i]._batch = null;\n    }\n    this._elements = null;\n    this.indexBuffer = null;\n    this.attributeBuffer.destroy();\n    this.attributeBuffer = null;\n  }\n};\n_Batcher.defaultOptions = {\n  maxTextures: null,\n  attributesInitialSize: 4,\n  indicesInitialSize: 6\n};\nlet Batcher = _Batcher;\nexport { Batch, Batcher };","map":{"version":3,"names":["Batch","constructor","renderPipeId","action","start","size","textures","BatchTextureArray","blendMode","canBundle","destroy","gpuBindGroup","bindGroup","batcher","batchPool","batchPoolIndex","getBatchFromPool","returnBatchToPool","batch","BATCH_TICK","_Batcher","options","uid","dirty","batchIndex","batches","_elements","defaultOptions","maxTextures","getMaxTexturesPerBatch","attributesInitialSize","indicesInitialSize","attributeBuffer","ViewableBuffer","indexBuffer","Uint16Array","begin","elementSize","elementStart","indexSize","attributeSize","i","_batchIndexStart","_batchIndexSize","add","batchableObject","_indexStart","_attributeStart","_batcher","vertexSize","checkAndUpdateTexture","texture","textureId","_batch","ids","_source","_textureId","updateElement","packAsQuad","packQuadAttributes","float32View","uint32View","packAttributes","break","instructionSet","elements","textureBatch","clear","firstElement","getAdjustedBlendModeBlend","_resizeAttributeBuffer","length","_resizeIndexBuffer","f32","u32","element","source","adjustedBlendMode","breakRequired","_batchTick","_textureBindLocation","packQuadIndex","packIndex","count","_finishBatch","indexStart","finish","ensureAttributeBuffer","ensureIndexBuffer","newSize","Math","max","newArrayBuffer","fastCopy","rawBinaryData","newIndexBuffer","Uint32Array","BYTES_PER_ELEMENT","buffer","index","indicesOffset","indices","indexOffset","attributeOffset","Batcher"],"sources":["/workspaces/royal-games-updated/node_modules/pixi.js/src/rendering/batcher/shared/Batcher.ts"],"sourcesContent":["import { uid } from '../../../utils/data/uid';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy';\nimport { type BLEND_MODES } from '../../renderers/shared/state/const';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures';\nimport { BatchTextureArray } from './BatchTextureArray';\n\nimport type { BoundsData } from '../../../scene/container/bounds/Bounds';\nimport type { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport type { Geometry, IndexBufferArray } from '../../renderers/shared/geometry/Geometry';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Texture } from '../../renderers/shared/texture/Texture';\n\nexport type BatchAction = 'startBatch' | 'renderBatch';\n\n/**\n * A batch pool is used to store batches when they are not currently in use.\n * @memberof rendering\n */\nexport class Batch implements Instruction\n{\n    public renderPipeId = 'batch';\n    public action: BatchAction = 'startBatch';\n\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n\n    // for drawing..\n    public start = 0;\n    public size = 0;\n    public textures: BatchTextureArray = new BatchTextureArray();\n\n    public blendMode: BLEND_MODES = 'normal';\n\n    public canBundle = true;\n\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the GPU bind group to set when rendering this batch for WebGPU. Will be null is using WebGL.\n     */\n    public gpuBindGroup: GPUBindGroup;\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the bind group to set when rendering this batch for WebGPU. Will be null if using WebGl.\n     */\n    public bindGroup: BindGroup;\n\n    public batcher: Batcher;\n\n    public destroy()\n    {\n        this.textures = null;\n        this.gpuBindGroup = null;\n        this.bindGroup = null;\n        this.batcher = null;\n    }\n}\n\n// inlined pool for SPEEEEEEEEEED :D\nconst batchPool: Batch[] = [];\nlet batchPoolIndex = 0;\n\nfunction getBatchFromPool()\n{\n    return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();\n}\n\nfunction returnBatchToPool(batch: Batch)\n{\n    batchPool[batchPoolIndex++] = batch;\n}\n\n/**\n * Represents an element that can be batched for rendering.\n * @interface\n * @memberof rendering\n */\nexport interface BatchableElement\n{\n    /**\n     * The name of the batcher to use. Must be registered.\n     * @type {string}\n     */\n    batcherName: string;\n\n    /**\n     * The texture to be used for rendering.\n     * @type {Texture}\n     */\n    texture: Texture;\n\n    /**\n     * The blend mode to be applied.\n     * @type {BLEND_MODES}\n     */\n    blendMode: BLEND_MODES;\n\n    /**\n     * The size of the index data.\n     * @type {number}\n     */\n    indexSize: number;\n\n    /**\n     * The size of the attribute data.\n     * @type {number}\n     */\n    attributeSize: number;\n\n    /**\n     * Whether the element should be packed as a quad for better performance.\n     * @type {boolean}\n     */\n    packAsQuad: boolean;\n\n    /**\n     * The texture ID, stored for efficient updating.\n     * @type {number}\n     * @private\n     */\n    _textureId: number;\n\n    /**\n     * The starting position in the attribute buffer.\n     * @type {number}\n     * @private\n     */\n    _attributeStart: number;\n\n    /**\n     * The starting position in the index buffer.\n     * @type {number}\n     * @private\n     */\n    _indexStart: number;\n\n    /**\n     * Reference to the batcher.\n     * @type {Batcher}\n     * @private\n     */\n    _batcher: Batcher;\n\n    /**\n     * Reference to the batch.\n     * @type {Batch}\n     * @private\n     */\n    _batch: Batch;\n}\n\n/**\n * Represents a batchable quad element.\n * @extends BatchableElement\n * @memberof rendering\n */\nexport interface BatchableQuadElement extends BatchableElement\n{\n    /**\n     * Indicates that this element should be packed as a quad.\n     * @type {true}\n     */\n    packAsQuad: true;\n\n    /**\n     * The size of the attribute data for this quad element.\n     * @type {4}\n     */\n    attributeSize: 4;\n\n    /**\n     * The size of the index data for this quad element.\n     * @type {6}\n     */\n    indexSize: 6;\n\n    /**\n     * The bounds data for this quad element.\n     * @type {BoundsData}\n     */\n    bounds: BoundsData;\n}\n\n/**\n * Represents a batchable mesh element.\n * @extends BatchableElement\n * @memberof rendering\n */\nexport interface BatchableMeshElement extends BatchableElement\n{\n    /**\n     * The UV coordinates of the mesh.\n     * @type {number[] | Float32Array}\n     */\n    uvs: number[] | Float32Array;\n\n    /**\n     * The vertex positions of the mesh.\n     * @type {number[] | Float32Array}\n     */\n    positions: number[] | Float32Array;\n\n    /**\n     * The indices of the mesh.\n     * @type {number[] | Uint16Array | Uint32Array}\n     */\n    indices: number[] | Uint16Array | Uint32Array;\n\n    /**\n     * The offset in the index buffer.\n     * @type {number}\n     */\n    indexOffset: number;\n\n    /**\n     * The offset in the attribute buffer.\n     * @type {number}\n     */\n    attributeOffset: number;\n\n    /**\n     * Indicates that this element should not be packed as a quad.\n     * @type {false}\n     */\n    packAsQuad: false;\n}\n\nlet BATCH_TICK = 0;\n\n/**\n * The options for the batcher.\n * @memberof rendering\n */\nexport interface BatcherOptions\n{\n    /** The maximum number of textures per batch. */\n    maxTextures?: number;\n    attributesInitialSize?: number;\n    indicesInitialSize?: number;\n}\n\n/**\n * A batcher is used to batch together objects with the same texture.\n * It is an abstract class that must be extended. see DefaultBatcher for an example.\n * @memberof rendering\n */\nexport abstract class Batcher\n{\n    public static defaultOptions: Partial<BatcherOptions> = {\n        maxTextures: null,\n        attributesInitialSize: 4,\n        indicesInitialSize: 6,\n    };\n\n    /** unique id for this batcher */\n    public readonly uid: number = uid('batcher');\n\n    /** The buffer containing attribute data for all elements in the batch. */\n    public attributeBuffer: ViewableBuffer;\n\n    /** The buffer containing index data for all elements in the batch. */\n    public indexBuffer: IndexBufferArray;\n\n    /** The current size of the attribute data in the batch. */\n    public attributeSize: number;\n\n    /** The current size of the index data in the batch. */\n    public indexSize: number;\n\n    /** The total number of elements currently in the batch. */\n    public elementSize: number;\n\n    /** The starting index of elements in the current batch. */\n    public elementStart: number;\n\n    /** Indicates whether the batch data has been modified and needs updating. */\n    public dirty = true;\n\n    /** The current index of the batch being processed. */\n    public batchIndex = 0;\n\n    /** An array of all batches created during the current rendering process. */\n    public batches: Batch[] = [];\n\n    private _elements: BatchableElement[] = [];\n\n    private _batchIndexStart: number;\n    private _batchIndexSize: number;\n\n    /** The maximum number of textures per batch. */\n    public readonly maxTextures: number;\n\n    /** The name of the batcher. Must be implemented by subclasses. */\n    public abstract name: string;\n    /** The vertex size of the batcher. Must be implemented by subclasses. */\n    protected abstract vertexSize: number;\n\n    /** The geometry used by this batcher. Must be implemented by subclasses. */\n    public abstract geometry: Geometry;\n\n    /**\n     * The shader used by this batcher. Must be implemented by subclasses.\n     * this can be shared by multiple batchers of the same type.\n     */\n    public abstract shader: Shader;\n\n    /**\n     * Packs the attributes of a BatchableMeshElement into the provided views.\n     * Must be implemented by subclasses.\n     * @param element - The BatchableMeshElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public abstract packAttributes(\n        element: BatchableMeshElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    ): void;\n\n    /**\n     * Packs the attributes of a BatchableQuadElement into the provided views.\n     * Must be implemented by subclasses.\n     * @param element - The BatchableQuadElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public abstract packQuadAttributes(\n        element: BatchableQuadElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    ): void;\n\n    constructor(options: BatcherOptions = {})\n    {\n        Batcher.defaultOptions.maxTextures = Batcher.defaultOptions.maxTextures ?? getMaxTexturesPerBatch();\n        options = { ...Batcher.defaultOptions, ...options };\n\n        const { maxTextures, attributesInitialSize, indicesInitialSize } = options;\n\n        this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);\n\n        this.indexBuffer = new Uint16Array(indicesInitialSize);\n\n        this.maxTextures = maxTextures;\n    }\n\n    public begin()\n    {\n        this.elementSize = 0;\n        this.elementStart = 0;\n        this.indexSize = 0;\n        this.attributeSize = 0;\n\n        for (let i = 0; i < this.batchIndex; i++)\n        {\n            returnBatchToPool(this.batches[i]);\n        }\n\n        this.batchIndex = 0;\n        this._batchIndexStart = 0;\n        this._batchIndexSize = 0;\n\n        this.dirty = true;\n    }\n\n    public add(batchableObject: BatchableElement)\n    {\n        this._elements[this.elementSize++] = batchableObject;\n\n        batchableObject._indexStart = this.indexSize;\n        batchableObject._attributeStart = this.attributeSize;\n        batchableObject._batcher = this;\n\n        this.indexSize += batchableObject.indexSize;\n        this.attributeSize += ((batchableObject.attributeSize) * this.vertexSize);\n    }\n\n    public checkAndUpdateTexture(batchableObject: BatchableElement, texture: Texture): boolean\n    {\n        const textureId = batchableObject._batch.textures.ids[texture._source.uid];\n\n        // TODO could try to be a bit smarter if there are spare textures..\n        // but need to figure out how to alter the bind groups too..\n        if (!textureId && textureId !== 0) return false;\n\n        batchableObject._textureId = textureId;\n        batchableObject.texture = texture;\n\n        return true;\n    }\n\n    public updateElement(batchableObject: BatchableElement)\n    {\n        this.dirty = true;\n\n        const attributeBuffer = this.attributeBuffer;\n\n        if (batchableObject.packAsQuad)\n        {\n            this.packQuadAttributes(\n                batchableObject as BatchableQuadElement,\n                attributeBuffer.float32View,\n                attributeBuffer.uint32View,\n                batchableObject._attributeStart, batchableObject._textureId);\n        }\n        else\n        {\n            this.packAttributes(\n                batchableObject as BatchableMeshElement,\n                attributeBuffer.float32View,\n                attributeBuffer.uint32View,\n                batchableObject._attributeStart, batchableObject._textureId);\n        }\n    }\n\n    /**\n     * breaks the batcher. This happens when a batch gets too big,\n     * or we need to switch to a different type of rendering (a filter for example)\n     * @param instructionSet\n     */\n    public break(instructionSet: InstructionSet)\n    {\n        const elements = this._elements;\n\n        // length 0??!! (we broke without adding anything)\n        if (!elements[this.elementStart]) return;\n\n        let batch = getBatchFromPool();\n        let textureBatch = batch.textures;\n\n        textureBatch.clear();\n\n        const firstElement = elements[this.elementStart];\n        let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n\n        if (this.attributeSize * 4 > this.attributeBuffer.size)\n        {\n            this._resizeAttributeBuffer(this.attributeSize * 4);\n        }\n\n        if (this.indexSize > this.indexBuffer.length)\n        {\n            this._resizeIndexBuffer(this.indexSize);\n        }\n\n        const f32 = this.attributeBuffer.float32View;\n        const u32 = this.attributeBuffer.uint32View;\n        const indexBuffer = this.indexBuffer;\n\n        let size = this._batchIndexSize;\n        let start = this._batchIndexStart;\n\n        let action: BatchAction = 'startBatch';\n\n        const maxTextures = this.maxTextures;\n\n        for (let i = this.elementStart; i < this.elementSize; ++i)\n        {\n            const element = elements[i];\n\n            elements[i] = null;\n\n            const texture = element.texture;\n            const source = texture._source;\n\n            const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n\n            const breakRequired = blendMode !== adjustedBlendMode;\n\n            if (source._batchTick === BATCH_TICK && !breakRequired)\n            {\n                element._textureId = source._textureBindLocation;\n\n                size += element.indexSize;\n\n                if (element.packAsQuad)\n                {\n                    this.packQuadAttributes(\n                        element as BatchableQuadElement,\n                        f32, u32,\n                        element._attributeStart, element._textureId\n                    );\n                    this.packQuadIndex(\n                        indexBuffer,\n                        element._indexStart,\n                        element._attributeStart / this.vertexSize\n                    );\n                }\n                else\n                {\n                    this.packAttributes(\n                        element as BatchableMeshElement,\n                        f32, u32,\n                        element._attributeStart,\n                        element._textureId\n                    );\n                    this.packIndex(\n                        element as BatchableMeshElement,\n                        indexBuffer,\n                        element._indexStart,\n                        element._attributeStart / this.vertexSize\n                    );\n                }\n\n                element._batch = batch;\n\n                continue;\n            }\n\n            source._batchTick = BATCH_TICK;\n\n            if (textureBatch.count >= maxTextures || breakRequired)\n            {\n                this._finishBatch(\n                    batch,\n                    start,\n                    size - start,\n                    textureBatch,\n                    blendMode,\n                    instructionSet,\n                    action\n                );\n\n                action = 'renderBatch';\n                start = size;\n                // create a batch...\n                blendMode = adjustedBlendMode;\n\n                batch = getBatchFromPool();\n                textureBatch = batch.textures;\n                textureBatch.clear();\n\n                ++BATCH_TICK;\n            }\n\n            element._textureId = source._textureBindLocation = textureBatch.count;\n            textureBatch.ids[source.uid] = textureBatch.count;\n            textureBatch.textures[textureBatch.count++] = source;\n            element._batch = batch;\n\n            size += element.indexSize;\n\n            if (element.packAsQuad)\n            {\n                this.packQuadAttributes(\n                    element as BatchableQuadElement,\n                    f32, u32,\n                    element._attributeStart, element._textureId\n                );\n                this.packQuadIndex(\n                    indexBuffer,\n                    element._indexStart,\n                    element._attributeStart / this.vertexSize\n                );\n            }\n            else\n            {\n                this.packAttributes(element as BatchableMeshElement,\n                    f32, u32,\n                    element._attributeStart, element._textureId\n                );\n\n                this.packIndex(\n                    element as BatchableMeshElement,\n                    indexBuffer,\n                    element._indexStart,\n                    element._attributeStart / this.vertexSize\n                );\n            }\n        }\n\n        if (textureBatch.count > 0)\n        {\n            this._finishBatch(\n                batch,\n                start,\n                size - start,\n                textureBatch,\n                blendMode,\n                instructionSet,\n                action\n            );\n\n            start = size;\n            ++BATCH_TICK;\n        }\n\n        this.elementStart = this.elementSize;\n        this._batchIndexStart = start;\n        this._batchIndexSize = size;\n    }\n\n    private _finishBatch(\n        batch: Batch,\n        indexStart: number,\n        indexSize: number,\n        textureBatch: BatchTextureArray,\n        blendMode: BLEND_MODES,\n        instructionSet: InstructionSet,\n        action: BatchAction\n    )\n    {\n        batch.gpuBindGroup = null;\n        batch.bindGroup = null;\n        batch.action = action;\n\n        batch.batcher = this;\n        batch.textures = textureBatch;\n        batch.blendMode = blendMode;\n\n        batch.start = indexStart;\n        batch.size = indexSize;\n\n        ++BATCH_TICK;\n\n        // track for returning later!\n        this.batches[this.batchIndex++] = batch;\n        instructionSet.add(batch);\n    }\n\n    public finish(instructionSet: InstructionSet)\n    {\n        this.break(instructionSet);\n    }\n\n    /**\n     * Resizes the attribute buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureAttributeBuffer(size: number)\n    {\n        if (size * 4 <= this.attributeBuffer.size) return;\n\n        this._resizeAttributeBuffer(size * 4);\n    }\n\n    /**\n     * Resizes the index buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureIndexBuffer(size: number)\n    {\n        if (size <= this.indexBuffer.length) return;\n\n        this._resizeIndexBuffer(size);\n    }\n\n    private _resizeAttributeBuffer(size: number)\n    {\n        const newSize = Math.max(size, this.attributeBuffer.size * 2);\n\n        const newArrayBuffer = new ViewableBuffer(newSize);\n\n        fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n\n        this.attributeBuffer = newArrayBuffer;\n    }\n\n    private _resizeIndexBuffer(size: number)\n    {\n        const indexBuffer = this.indexBuffer;\n\n        let newSize = Math.max(size, indexBuffer.length * 1.5);\n\n        newSize += newSize % 2;\n\n        // this, is technically not 100% accurate, as really we should\n        // be checking the maximum value in the buffer. This approximation\n        // does the trick though...\n\n        // make sure buffer is always an even number..\n        const newIndexBuffer = (newSize > 65535) ? new Uint32Array(newSize) : new Uint16Array(newSize);\n\n        if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT)\n        {\n            for (let i = 0; i < indexBuffer.length; i++)\n            {\n                newIndexBuffer[i] = indexBuffer[i];\n            }\n        }\n        else\n        {\n            fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n        }\n\n        this.indexBuffer = newIndexBuffer;\n    }\n\n    public packQuadIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        indexBuffer[index] = indicesOffset + 0;\n        indexBuffer[index + 1] = indicesOffset + 1;\n        indexBuffer[index + 2] = indicesOffset + 2;\n\n        indexBuffer[index + 3] = indicesOffset + 0;\n        indexBuffer[index + 4] = indicesOffset + 2;\n        indexBuffer[index + 5] = indicesOffset + 3;\n    }\n\n    public packIndex(element: BatchableMeshElement, indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        const indices = element.indices;\n        const size = element.indexSize;\n        const indexOffset = element.indexOffset;\n        const attributeOffset = element.attributeOffset;\n\n        for (let i = 0; i < size; i++)\n        {\n            indexBuffer[index++] = indicesOffset + indices[i + indexOffset] - attributeOffset;\n        }\n    }\n\n    public destroy()\n    {\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            returnBatchToPool(this.batches[i]);\n        }\n\n        this.batches = null;\n\n        for (let i = 0; i < this._elements.length; i++)\n        {\n            this._elements[i]._batch = null;\n        }\n\n        this._elements = null;\n\n        this.indexBuffer = null;\n\n        this.attributeBuffer.destroy();\n        this.attributeBuffer = null;\n    }\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}