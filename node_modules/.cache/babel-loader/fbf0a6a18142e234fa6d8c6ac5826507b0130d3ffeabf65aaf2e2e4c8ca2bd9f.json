{"ast":null,"code":"\"use strict\";\n\nclass BatchableMesh {\n  constructor() {\n    this.batcherName = \"default\";\n    this.packAsQuad = false;\n    this.indexOffset = 0;\n    this.attributeOffset = 0;\n    this.roundPixels = 0;\n    this._batcher = null;\n    this._batch = null;\n    this._uvUpdateId = -1;\n    this._textureMatrixUpdateId = -1;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this._batcher = null;\n    this._batch = null;\n    this.geometry = null;\n    this._uvUpdateId = -1;\n    this._textureMatrixUpdateId = -1;\n  }\n  get uvs() {\n    const geometry = this.geometry;\n    const uvBuffer = geometry.getBuffer(\"aUV\");\n    const uvs = uvBuffer.data;\n    let transformedUvs = uvs;\n    const textureMatrix = this.texture.textureMatrix;\n    if (!textureMatrix.isSimple) {\n      transformedUvs = this._transformedUvs;\n      if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID) {\n        if (!transformedUvs || transformedUvs.length < uvs.length) {\n          transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n        }\n        this._textureMatrixUpdateId = textureMatrix._updateID;\n        this._uvUpdateId = uvBuffer._updateID;\n        textureMatrix.multiplyUvs(uvs, transformedUvs);\n      }\n    }\n    return transformedUvs;\n  }\n  get positions() {\n    return this.geometry.positions;\n  }\n  get indices() {\n    return this.geometry.indices;\n  }\n  get color() {\n    return this.renderable.groupColorAlpha;\n  }\n  get groupTransform() {\n    return this.renderable.groupTransform;\n  }\n  get attributeSize() {\n    return this.geometry.positions.length / 2;\n  }\n  get indexSize() {\n    return this.geometry.indices.length;\n  }\n}\nexport { BatchableMesh };","map":{"version":3,"names":["BatchableMesh","constructor","batcherName","packAsQuad","indexOffset","attributeOffset","roundPixels","_batcher","_batch","_uvUpdateId","_textureMatrixUpdateId","blendMode","renderable","groupBlendMode","reset","texture","geometry","uvs","uvBuffer","getBuffer","data","transformedUvs","textureMatrix","isSimple","_transformedUvs","_updateID","length","Float32Array","multiplyUvs","positions","indices","color","groupColorAlpha","groupTransform","attributeSize","indexSize"],"sources":["/workspaces/royal-games-updated/node_modules/pixi.js/src/scene/mesh/shared/BatchableMesh.ts"],"sourcesContent":["import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableMeshElement } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { ViewContainer } from '../../view/View';\nimport type { MeshGeometry } from './MeshGeometry';\n\n/**\n * A batchable mesh object.\n * @ignore\n */\nexport class BatchableMesh implements DefaultBatchableMeshElement\n{\n    public batcherName = 'default';\n    public readonly packAsQuad = false;\n    public location: number;\n\n    public renderable: ViewContainer;\n\n    public indexOffset = 0;\n    public attributeOffset = 0;\n\n    public texture: Texture;\n    public geometry: MeshGeometry;\n    public transform: Matrix;\n    public roundPixels: 0 | 1 = 0;\n\n    public _attributeStart: number;\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n    public _indexStart: number;\n    public _textureId: number;\n\n    private _transformedUvs: Float32Array;\n    private _uvUpdateId: number = -1;\n    private _textureMatrixUpdateId: number = -1;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.geometry = null;\n        this._uvUpdateId = -1;\n        this._textureMatrixUpdateId = -1;\n    }\n\n    get uvs()\n    {\n        const geometry = this.geometry;\n\n        const uvBuffer = geometry.getBuffer('aUV');\n\n        const uvs = uvBuffer.data;\n\n        let transformedUvs = uvs;\n        const textureMatrix = this.texture.textureMatrix;\n\n        if (!textureMatrix.isSimple)\n        {\n            transformedUvs = this._transformedUvs;\n\n            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID)\n            {\n                if (!transformedUvs || transformedUvs.length < uvs.length)\n                {\n                    transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n                }\n\n                this._textureMatrixUpdateId = textureMatrix._updateID;\n                this._uvUpdateId = uvBuffer._updateID;\n\n                textureMatrix.multiplyUvs(uvs as Float32Array, transformedUvs);\n            }\n        }\n\n        return transformedUvs as Float32Array;\n    }\n\n    get positions()\n    {\n        return this.geometry.positions;\n    }\n\n    get indices()\n    {\n        return this.geometry.indices;\n    }\n\n    get color()\n    {\n        return this.renderable.groupColorAlpha;\n    }\n\n    get groupTransform()\n    {\n        return this.renderable.groupTransform;\n    }\n\n    get attributeSize()\n    {\n        return this.geometry.positions.length / 2;\n    }\n\n    get indexSize()\n    {\n        return this.geometry.indices.length;\n    }\n}\n"],"mappings":";;AAWO,MAAMA,aACb;EADOC,YAAA;IAEH,KAAOC,WAAc;IACrB,KAAgBC,UAAa;IAK7B,KAAOC,WAAc;IACrB,KAAOC,eAAkB;IAKzB,KAAOC,WAAqB;IAG5B,KAAOC,QAAoB;IAC3B,KAAOC,MAAgB;IAKvB,KAAQC,WAAsB;IAC9B,KAAQC,sBAAiC;EAAA;EAEzC,IAAIC,SAAYA,CAAA;IAAE,OAAO,KAAKC,UAAW,CAAAC,cAAA;EAAA;EAElCC,KACPA,CAAA;IACI,KAAKF,UAAa;IAClB,KAAKG,OAAU;IACf,KAAKR,QAAW;IAChB,KAAKC,MAAS;IACd,KAAKQ,QAAW;IAChB,KAAKP,WAAc;IACnB,KAAKC,sBAAyB;EAAA;EAGlC,IAAIO,GACJA,CAAA;IACI,MAAMD,QAAA,GAAW,IAAK,CAAAA,QAAA;IAEhB,MAAAE,QAAA,GAAWF,QAAS,CAAAG,SAAA,CAAU,KAAK;IAEzC,MAAMF,GAAA,GAAMC,QAAS,CAAAE,IAAA;IAErB,IAAIC,cAAiB,GAAAJ,GAAA;IACf,MAAAK,aAAA,GAAgB,KAAKP,OAAQ,CAAAO,aAAA;IAE/B,KAACA,aAAA,CAAcC,QACnB;MACIF,cAAA,GAAiB,IAAK,CAAAG,eAAA;MAEtB,IAAI,KAAKd,sBAA2B,KAAAY,aAAA,CAAcG,SAAA,IAAa,IAAK,CAAAhB,WAAA,KAAgBS,QAAA,CAASO,SAC7F;QACI,IAAI,CAACJ,cAAA,IAAkBA,cAAe,CAAAK,MAAA,GAAST,GAAA,CAAIS,MACnD;UACIL,cAAA,GAAiB,IAAK,CAAAG,eAAA,GAAkB,IAAIG,YAAA,CAAaV,GAAA,CAAIS,MAAM;QAAA;QAGvE,KAAKhB,sBAAA,GAAyBY,aAAc,CAAAG,SAAA;QAC5C,KAAKhB,WAAA,GAAcS,QAAS,CAAAO,SAAA;QAEdH,aAAA,CAAAM,WAAA,CAAYX,GAAA,EAAqBI,cAAc;MAAA;IACjE;IAGG,OAAAA,cAAA;EAAA;EAGX,IAAIQ,SACJA,CAAA;IACI,OAAO,KAAKb,QAAS,CAAAa,SAAA;EAAA;EAGzB,IAAIC,OACJA,CAAA;IACI,OAAO,KAAKd,QAAS,CAAAc,OAAA;EAAA;EAGzB,IAAIC,KACJA,CAAA;IACI,OAAO,KAAKnB,UAAW,CAAAoB,eAAA;EAAA;EAG3B,IAAIC,cACJA,CAAA;IACI,OAAO,KAAKrB,UAAW,CAAAqB,cAAA;EAAA;EAG3B,IAAIC,aACJA,CAAA;IACW,YAAKlB,QAAS,CAAAa,SAAA,CAAUH,MAAS;EAAA;EAG5C,IAAIS,SACJA,CAAA;IACW,YAAKnB,QAAA,CAASc,OAAQ,CAAAJ,MAAA;EAAA;AAErC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}