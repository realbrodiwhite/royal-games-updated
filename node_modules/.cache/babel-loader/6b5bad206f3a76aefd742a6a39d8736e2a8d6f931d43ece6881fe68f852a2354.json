{"ast":null,"code":"import { Cache } from '../../../../../assets/cache/Cache.mjs';\nimport { extensions, ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { TextureSource } from '../sources/TextureSource.mjs';\nimport { Texture } from '../Texture.mjs';\n\"use strict\";\nconst sources = [];\nextensions.handleByList(ExtensionType.TextureSource, sources);\nfunction autoDetectSource() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return textureSourceFrom(options);\n}\nfunction textureSourceFrom() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const hasResource = options && options.resource;\n  const res = hasResource ? options.resource : options;\n  const opts = hasResource ? options : {\n    resource: options\n  };\n  for (let i = 0; i < sources.length; i++) {\n    const Source = sources[i];\n    if (Source.test(res)) {\n      return new Source(opts);\n    }\n  }\n  throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\nfunction resourceToTexture() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let skipCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const hasResource = options && options.resource;\n  const resource = hasResource ? options.resource : options;\n  const opts = hasResource ? options : {\n    resource: options\n  };\n  if (!skipCache && Cache.has(resource)) {\n    return Cache.get(resource);\n  }\n  const texture = new Texture({\n    source: textureSourceFrom(opts)\n  });\n  texture.on(\"destroy\", () => {\n    if (Cache.has(resource)) {\n      Cache.remove(resource);\n    }\n  });\n  if (!skipCache) {\n    Cache.set(resource, texture);\n  }\n  return texture;\n}\nfunction textureFrom(id) {\n  let skipCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (typeof id === \"string\") {\n    return Cache.get(id);\n  } else if (id instanceof TextureSource) {\n    return new Texture({\n      source: id\n    });\n  }\n  return resourceToTexture(id, skipCache);\n}\nTexture.from = textureFrom;\nTextureSource.from = textureSourceFrom;\nexport { autoDetectSource, resourceToTexture, textureFrom };","map":{"version":3,"names":["sources","extensions","handleByList","ExtensionType","TextureSource","autoDetectSource","options","arguments","length","undefined","textureSourceFrom","hasResource","resource","res","opts","i","Source","test","Error","resourceToTexture","skipCache","Cache","has","get","texture","Texture","source","on","remove","set","textureFrom","id","from"],"sources":["/workspaces/royal-games-updated/node_modules/pixi.js/src/rendering/renderers/shared/texture/utils/textureFrom.ts"],"sourcesContent":["import { Cache } from '../../../../../assets/cache/Cache';\nimport { extensions, ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from '../sources/TextureSource';\nimport { Texture } from '../Texture';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { TypedArray } from '../../buffer/Buffer';\nimport type { BufferSourceOptions } from '../sources/BufferImageSource';\nimport type { CanvasSourceOptions } from '../sources/CanvasSource';\nimport type { ImageResource } from '../sources/ImageSource';\nimport type { TextureSourceOptions } from '../sources/TextureSource';\nimport type { TextureSourceLike } from '../Texture';\n\ninterface TextureSourceConstructor<T extends TextureSource = TextureSource>\n{\n    new (options: TextureSourceOptions): T;\n    test(options: ImageResource | TypedArray | ArrayBuffer | ICanvas): boolean;\n}\n\nconst sources: TextureSourceConstructor[] = [];\n\nextensions.handleByList(ExtensionType.TextureSource, sources);\n\nexport type TextureResourceOrOptions =\n  ImageResource\n  | TextureSourceOptions<ImageResource>\n  | BufferSourceOptions\n  | CanvasSourceOptions;\n\n/**\n * @param options\n * @deprecated since v8.2.0\n * @see TextureSource.from\n */\nexport function autoDetectSource(options: TextureResourceOrOptions = {}): TextureSource\n{\n    return textureSourceFrom(options);\n}\n\n/**\n * Creates a texture source from the options provided\n * @param options - The options to create the texture source from. This can be\n */\nfunction textureSourceFrom(options: TextureResourceOrOptions = {}): TextureSource\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const res = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    for (let i = 0; i < sources.length; i++)\n    {\n        const Source = sources[i];\n\n        if (Source.test(res))\n        {\n            return new Source(opts);\n        }\n    }\n\n    throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\n\nexport function resourceToTexture(\n    options: TextureResourceOrOptions = {},\n    skipCache = false\n): Texture\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const resource = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    if (!skipCache && Cache.has(resource))\n    {\n        return Cache.get(resource);\n    }\n\n    const texture = new Texture({ source: textureSourceFrom(opts) });\n\n    texture.on('destroy', () =>\n    {\n        if (Cache.has(resource))\n        {\n            Cache.remove(resource);\n        }\n    });\n\n    if (!skipCache)\n    {\n        Cache.set(resource, texture);\n    }\n\n    return texture;\n}\n\n/**\n * Helper function that creates a returns Texture based on the source you provide.\n * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n * @param id - String or Source to create texture from\n * @param skipCache - Skip adding the texture to the cache\n * @returns The texture based on the Id provided\n */\nexport function textureFrom(id: TextureSourceLike, skipCache = false): Texture\n{\n    if (typeof id === 'string')\n    {\n        return Cache.get(id);\n    }\n    else if (id instanceof TextureSource)\n    {\n        return new Texture({ source: id });\n    }\n\n    // return a auto generated texture from resource\n    return resourceToTexture(id, skipCache);\n}\n\nTexture.from = textureFrom;\nTextureSource.from = textureSourceFrom;\n"],"mappings":";;;;;AAmBA,MAAMA,OAAA,GAAsC,EAAC;AAE7CC,UAAW,CAAAC,YAAA,CAAaC,aAAc,CAAAC,aAAA,EAAeJ,OAAO;AAa5C,SAAAK,iBAAA,EAChB;EAAA,IADiCC,OAAoC,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,QACrE;EACI,OAAOG,iBAAA,CAAkBJ,OAAO;AACpC;AAMA,SAASI,kBAAA,EACT;EAAA,IAD2BJ,OAAoC,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,QAC/D;EACU,MAAAI,WAAA,GAAcL,OAAA,IAAYA,OAAiC,CAAAM,QAAA;EAC3D,MAAAC,GAAA,GAAMF,WAAe,GAAAL,OAAA,CAAiCM,QAAW,GAAAN,OAAA;EACvE,MAAMQ,IAAO,GAAAH,WAAA,GAAcL,OAAkC;IAAEM,QAAA,EAAUN;EAAQ;EAEjF,SAASS,CAAI,MAAGA,CAAI,GAAAf,OAAA,CAAQQ,MAAA,EAAQO,CACpC;IACU,MAAAC,MAAA,GAAShB,OAAA,CAAQe,CAAC;IAEpB,IAAAC,MAAA,CAAOC,IAAK,CAAAJ,GAAG,CACnB;MACW,WAAIG,MAAA,CAAOF,IAAI;IAAA;EAC1B;EAGJ,MAAM,IAAII,KAAA,CAAM,8CAA8CJ,IAAA,CAAKF,QAAQ,EAAE;AACjF;AAEO,SAASO,iBACZA,CAAA,EAGJ;EAAA,IAHIb,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAoC,EAAC;EAAA,IACrCa,SAAA,GAAAb,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAY,KAEhB;EACU,MAAAI,WAAA,GAAcL,OAAA,IAAYA,OAAiC,CAAAM,QAAA;EAC3D,MAAAA,QAAA,GAAWD,WAAe,GAAAL,OAAA,CAAiCM,QAAW,GAAAN,OAAA;EAC5E,MAAMQ,IAAO,GAAAH,WAAA,GAAcL,OAAkC;IAAEM,QAAA,EAAUN;EAAQ;EAEjF,IAAI,CAACc,SAAA,IAAaC,KAAM,CAAAC,GAAA,CAAIV,QAAQ,CACpC;IACW,OAAAS,KAAA,CAAME,GAAA,CAAIX,QAAQ;EAAA;EAGvB,MAAAY,OAAA,GAAU,IAAIC,OAAQ;IAAEC,MAAA,EAAQhB,iBAAkB,CAAAI,IAAI;EAAA,CAAG;EAEvDU,OAAA,CAAAG,EAAA,CAAG,WAAW,MACtB;IACQ,IAAAN,KAAA,CAAMC,GAAI,CAAAV,QAAQ,CACtB;MACIS,KAAA,CAAMO,MAAA,CAAOhB,QAAQ;IAAA;EACzB,CACH;EAED,IAAI,CAACQ,SACL;IACUC,KAAA,CAAAQ,GAAA,CAAIjB,QAAA,EAAUY,OAAO;EAAA;EAGxB,OAAAA,OAAA;AACX;AASgB,SAAAM,YAAYC,EAAuB,EACnD;EAAA,IADmDX,SAAA,GAAAb,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAY,KAC/D;EACQ,WAAOwB,EAAA,KAAO,QAClB;IACW,OAAAV,KAAA,CAAME,GAAA,CAAIQ,EAAE;EAAA,CACvB,UACSA,EAAA,YAAc3B,aACvB;IACI,OAAO,IAAIqB,OAAA,CAAQ;MAAEC,MAAA,EAAQK;IAAA,CAAI;EAAA;EAI9B,OAAAZ,iBAAA,CAAkBY,EAAA,EAAIX,SAAS;AAC1C;AAEAK,OAAA,CAAQO,IAAO,GAAAF,WAAA;AACf1B,aAAA,CAAc4B,IAAO,GAAAtB,iBAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}