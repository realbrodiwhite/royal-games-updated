{"ast":null,"code":"import { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\"use strict\";\nconst buildCircle = {\n  extension: {\n    type: ExtensionType.ShapeBuilder,\n    name: \"circle\"\n  },\n  build(shape, points) {\n    let x;\n    let y;\n    let dx;\n    let dy;\n    let rx;\n    let ry;\n    if (shape.type === \"circle\") {\n      const circle = shape;\n      x = circle.x;\n      y = circle.y;\n      rx = ry = circle.radius;\n      dx = dy = 0;\n    } else if (shape.type === \"ellipse\") {\n      const ellipse = shape;\n      x = ellipse.x;\n      y = ellipse.y;\n      rx = ellipse.halfWidth;\n      ry = ellipse.halfHeight;\n      dx = dy = 0;\n    } else {\n      const roundedRect = shape;\n      const halfWidth = roundedRect.width / 2;\n      const halfHeight = roundedRect.height / 2;\n      x = roundedRect.x + halfWidth;\n      y = roundedRect.y + halfHeight;\n      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n      dx = halfWidth - rx;\n      dy = halfHeight - ry;\n    }\n    if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0)) {\n      return points;\n    }\n    const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n    const m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    if (m === 0) {\n      return points;\n    }\n    if (n === 0) {\n      points[0] = points[6] = x + dx;\n      points[1] = points[3] = y + dy;\n      points[2] = points[4] = x - dx;\n      points[5] = points[7] = y - dy;\n      return points;\n    }\n    let j1 = 0;\n    let j2 = n * 4 + (dx ? 2 : 0) + 2;\n    let j3 = j2;\n    let j4 = m;\n    let x0 = dx + rx;\n    let y0 = dy;\n    let x1 = x + x0;\n    let x2 = x - x0;\n    let y1 = y + y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j2] = y1;\n    points[--j2] = x2;\n    if (dy) {\n      const y22 = y - y0;\n      points[j3++] = x2;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x1;\n    }\n    for (let i = 1; i < n; i++) {\n      const a = Math.PI / 2 * (i / n);\n      const x02 = dx + Math.cos(a) * rx;\n      const y02 = dy + Math.sin(a) * ry;\n      const x12 = x + x02;\n      const x22 = x - x02;\n      const y12 = y + y02;\n      const y22 = y - y02;\n      points[j1++] = x12;\n      points[j1++] = y12;\n      points[--j2] = y12;\n      points[--j2] = x22;\n      points[j3++] = x22;\n      points[j3++] = y22;\n      points[--j4] = y22;\n      points[--j4] = x12;\n    }\n    x0 = dx;\n    y0 = dy + ry;\n    x1 = x + x0;\n    x2 = x - x0;\n    y1 = y + y0;\n    const y2 = y - y0;\n    points[j1++] = x1;\n    points[j1++] = y1;\n    points[--j4] = y2;\n    points[--j4] = x1;\n    if (dx) {\n      points[j1++] = x2;\n      points[j1++] = y1;\n      points[--j4] = y2;\n      points[--j4] = x2;\n    }\n    return points;\n  },\n  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {\n    if (points.length === 0) {\n      return;\n    }\n    let centerX = 0;\n    let centerY = 0;\n    for (let i = 0; i < points.length; i += 2) {\n      centerX += points[i];\n      centerY += points[i + 1];\n    }\n    centerX /= points.length / 2;\n    centerY /= points.length / 2;\n    let count = verticesOffset;\n    vertices[count * verticesStride] = centerX;\n    vertices[count * verticesStride + 1] = centerY;\n    const centerIndex = count++;\n    for (let i = 0; i < points.length; i += 2) {\n      vertices[count * verticesStride] = points[i];\n      vertices[count * verticesStride + 1] = points[i + 1];\n      if (i > 0) {\n        indices[indicesOffset++] = count;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n      }\n      count++;\n    }\n    indices[indicesOffset++] = centerIndex + 1;\n    indices[indicesOffset++] = centerIndex;\n    indices[indicesOffset++] = count - 1;\n  }\n};\nconst buildEllipse = {\n  ...buildCircle,\n  extension: {\n    ...buildCircle.extension,\n    name: \"ellipse\"\n  }\n};\nconst buildRoundedRectangle = {\n  ...buildCircle,\n  extension: {\n    ...buildCircle.extension,\n    name: \"roundedRectangle\"\n  }\n};\nexport { buildCircle, buildEllipse, buildRoundedRectangle };","map":{"version":3,"names":["buildCircle","extension","type","ExtensionType","ShapeBuilder","name","build","shape","points","x","y","dx","dy","rx","ry","circle","radius","ellipse","halfWidth","halfHeight","roundedRect","width","height","Math","max","min","n","ceil","sqrt","m","j1","j2","j3","j4","x0","y0","x1","x2","y1","y22","i","a","PI","x02","cos","y02","sin","x12","x22","y12","y2","triangulate","vertices","verticesStride","verticesOffset","indices","indicesOffset","length","centerX","centerY","count","centerIndex","buildEllipse","buildRoundedRectangle"],"sources":["/workspaces/royal-games-updated/node_modules/pixi.js/src/scene/graphics/shared/buildCommands/buildCircle.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Circle } from '../../../../maths/shapes/Circle';\nimport type { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport type { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport type { ShapeBuildCommand } from './ShapeBuildCommand';\n\ntype RoundedShape = Circle | Ellipse | RoundedRectangle;\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n * @ignore\n * @private\n */\nexport const buildCircle: ShapeBuildCommand<RoundedShape> = {\n    extension: {\n        type: ExtensionType.ShapeBuilder,\n        name: 'circle',\n    },\n\n    build(shape: RoundedShape, points: number[])\n    {\n        let x;\n        let y;\n        let dx;\n        let dy;\n\n        let rx;\n        let ry;\n\n        if (shape.type === 'circle')\n        {\n            const circle = shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n            rx = ry = circle.radius;\n            dx = dy = 0;\n        }\n\n        else if (shape.type === 'ellipse')\n        {\n            const ellipse = shape as Ellipse;\n\n            x = ellipse.x;\n            y = ellipse.y;\n            rx = ellipse.halfWidth;\n            ry = ellipse.halfHeight;\n            dx = dy = 0;\n        }\n        else\n        {\n            const roundedRect = shape as RoundedRectangle;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n\n        if (!(rx >= 0 && ry >= 0 && dx >= 0 && dy >= 0))\n        {\n            return points;\n        }\n\n        // Choose a number of segments such that the maximum absolute deviation from the circle is approximately 0.029\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = (n * 8) + (dx ? 4 : 0) + (dy ? 4 : 0);\n\n        if (m === 0)\n        {\n            return points;\n        }\n\n        if (n === 0)\n        {\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n\n            return points;\n        }\n\n        let j1 = 0;\n        let j2 = (n * 4) + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n\n        let x0 = dx + rx;\n        let y0 = dy;\n        let x1 = x + x0;\n        let x2 = x - x0;\n        let y1 = y + y0;\n\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j2] = y1;\n        points[--j2] = x2;\n\n        if (dy)\n        {\n            const y2 = y - y0;\n\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        for (let i = 1; i < n; i++)\n        {\n            const a = Math.PI / 2 * (i / n);\n            const x0 = dx + (Math.cos(a) * rx);\n            const y0 = dy + (Math.sin(a) * ry);\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        x0 = dx;\n        y0 = dy + ry;\n        x1 = x + x0;\n        x2 = x - x0;\n        y1 = y + y0;\n        const y2 = y - y0;\n\n        points[j1++] = x1;\n        points[j1++] = y1;\n        points[--j4] = y2;\n        points[--j4] = x1;\n\n        if (dx)\n        {\n            points[j1++] = x2;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x2;\n        }\n\n        return points;\n    },\n\n    triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset)\n    {\n        if (points.length === 0)\n        {\n            return;\n        }\n\n        // Compute center (average of all points)\n        let centerX = 0; let\n            centerY = 0;\n\n        for (let i = 0; i < points.length; i += 2)\n        {\n            centerX += points[i];\n            centerY += points[i + 1];\n        }\n        centerX /= (points.length / 2);\n        centerY /= (points.length / 2);\n\n        // Set center vertex\n        let count = verticesOffset;\n\n        vertices[count * verticesStride] = centerX;\n        vertices[(count * verticesStride) + 1] = centerY;\n        const centerIndex = count++;\n\n        // Set edge vertices and indices\n        for (let i = 0; i < points.length; i += 2)\n        {\n            vertices[count * verticesStride] = points[i];\n            vertices[(count * verticesStride) + 1] = points[i + 1];\n\n            if (i > 0)\n            { // Skip first point for indices\n                indices[indicesOffset++] = count;\n                indices[indicesOffset++] = centerIndex;\n                indices[indicesOffset++] = count - 1;\n            }\n            count++;\n        }\n\n        // Connect last point to the first edge point\n        indices[indicesOffset++] = centerIndex + 1;\n        indices[indicesOffset++] = centerIndex;\n        indices[indicesOffset++] = count - 1;\n    }\n\n};\n\nexport const buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: 'ellipse' } };\nexport const buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: 'roundedRectangle' } };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}