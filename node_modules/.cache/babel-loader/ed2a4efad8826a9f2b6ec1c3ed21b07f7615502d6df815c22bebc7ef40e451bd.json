{"ast":null,"code":"import { Container, UPDATE_VISIBLE, UPDATE_COLOR, UPDATE_BLEND } from '../Container.mjs';\nimport { clearList } from './clearList.mjs';\nimport { mixColors } from './mixColors.mjs';\n\"use strict\";\nconst tempContainer = new Container();\nconst UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;\nfunction updateRenderGroupTransforms(renderGroup) {\n  let updateChildRenderGroups = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  updateRenderGroupTransform(renderGroup);\n  const childrenToUpdate = renderGroup.childrenToUpdate;\n  const updateTick = renderGroup.updateTick++;\n  for (const j in childrenToUpdate) {\n    const renderGroupDepth = Number(j);\n    const childrenAtDepth = childrenToUpdate[j];\n    const list = childrenAtDepth.list;\n    const index = childrenAtDepth.index;\n    for (let i = 0; i < index; i++) {\n      const child = list[i];\n      if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth) {\n        updateTransformAndChildren(child, updateTick, 0);\n      }\n    }\n    clearList(list, index);\n    childrenAtDepth.index = 0;\n  }\n  if (updateChildRenderGroups) {\n    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n      updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n    }\n  }\n}\nfunction updateRenderGroupTransform(renderGroup) {\n  const root = renderGroup.root;\n  let worldAlpha;\n  if (renderGroup.renderGroupParent) {\n    const renderGroupParent = renderGroup.renderGroupParent;\n    renderGroup.worldTransform.appendFrom(root.relativeGroupTransform, renderGroupParent.worldTransform);\n    renderGroup.worldColor = mixColors(root.groupColor, renderGroupParent.worldColor);\n    worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n  } else {\n    renderGroup.worldTransform.copyFrom(root.localTransform);\n    renderGroup.worldColor = root.localColor;\n    worldAlpha = root.localAlpha;\n  }\n  worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;\n  renderGroup.worldAlpha = worldAlpha;\n  renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);\n}\nfunction updateTransformAndChildren(container, updateTick, updateFlags) {\n  if (updateTick === container.updateTick) return;\n  container.updateTick = updateTick;\n  container.didChange = false;\n  const localTransform = container.localTransform;\n  container.updateLocalTransform();\n  const parent = container.parent;\n  if (parent && !parent.renderGroup) {\n    updateFlags = updateFlags | container._updateFlags;\n    container.relativeGroupTransform.appendFrom(localTransform, parent.relativeGroupTransform);\n    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {\n      updateColorBlendVisibility(container, parent, updateFlags);\n    }\n  } else {\n    updateFlags = container._updateFlags;\n    container.relativeGroupTransform.copyFrom(localTransform);\n    if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE) {\n      updateColorBlendVisibility(container, tempContainer, updateFlags);\n    }\n  }\n  if (!container.renderGroup) {\n    const children = container.children;\n    const length = children.length;\n    for (let i = 0; i < length; i++) {\n      updateTransformAndChildren(children[i], updateTick, updateFlags);\n    }\n    const renderGroup = container.parentRenderGroup;\n    if (container.renderPipeId && !renderGroup.structureDidChange) {\n      renderGroup.updateRenderable(container);\n    }\n  }\n}\nfunction updateColorBlendVisibility(container, parent, updateFlags) {\n  if (updateFlags & UPDATE_COLOR) {\n    container.groupColor = mixColors(container.localColor, parent.groupColor);\n    let groupAlpha = container.localAlpha * parent.groupAlpha;\n    groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;\n    container.groupAlpha = groupAlpha;\n    container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);\n  }\n  if (updateFlags & UPDATE_BLEND) {\n    container.groupBlendMode = container.localBlendMode === \"inherit\" ? parent.groupBlendMode : container.localBlendMode;\n  }\n  if (updateFlags & UPDATE_VISIBLE) {\n    container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n  }\n  container._updateFlags = 0;\n}\nexport { updateRenderGroupTransform, updateRenderGroupTransforms, updateTransformAndChildren };","map":{"version":3,"names":["tempContainer","Container","UPDATE_BLEND_COLOR_VISIBLE","UPDATE_VISIBLE","UPDATE_COLOR","UPDATE_BLEND","updateRenderGroupTransforms","renderGroup","updateChildRenderGroups","arguments","length","undefined","updateRenderGroupTransform","childrenToUpdate","updateTick","j","renderGroupDepth","Number","childrenAtDepth","list","index","i","child","parentRenderGroup","relativeRenderGroupDepth","updateTransformAndChildren","clearList","renderGroupChildren","root","worldAlpha","renderGroupParent","worldTransform","appendFrom","relativeGroupTransform","worldColor","mixColors","groupColor","groupAlpha","copyFrom","localTransform","localColor","localAlpha","worldColorAlpha","container","updateFlags","didChange","updateLocalTransform","parent","_updateFlags","updateColorBlendVisibility","children","renderPipeId","structureDidChange","updateRenderable","groupColorAlpha","groupBlendMode","localBlendMode","globalDisplayStatus","localDisplayStatus"],"sources":["/workspaces/royal-games-updated/node_modules/pixi.js/src/scene/container/utils/updateRenderGroupTransforms.ts"],"sourcesContent":["import { Container, UPDATE_BLEND, UPDATE_COLOR, UPDATE_VISIBLE } from '../Container';\nimport { clearList } from './clearList';\nimport { mixColors } from './mixColors';\n\nimport type { RenderGroup } from '../RenderGroup';\n\nconst tempContainer = new Container();\nconst UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;\n\nexport function updateRenderGroupTransforms(renderGroup: RenderGroup, updateChildRenderGroups = false)\n{\n    updateRenderGroupTransform(renderGroup);\n\n    const childrenToUpdate = renderGroup.childrenToUpdate;\n\n    const updateTick = renderGroup.updateTick++;\n\n    for (const j in childrenToUpdate)\n    {\n        const renderGroupDepth = Number(j);\n\n        const childrenAtDepth = childrenToUpdate[j];\n\n        const list = childrenAtDepth.list;\n        const index = childrenAtDepth.index;\n\n        for (let i = 0; i < index; i++)\n        {\n            const child = list[i];\n\n            // check that these things match our layer and depth - if the renderGroup does not match,\n            // the child has been re-parented into another rendergroup since it asked to be updated so we can ignore it here\n            // secondly if the relativeRenderGroupDepth has changed, then the it means it will have been nested at a\n            // different different level in the render group - so we can wait for the update that does in fact match\n            if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth)\n            {\n                updateTransformAndChildren(child, updateTick, 0);\n            }\n        }\n\n        clearList(list, index);\n\n        childrenAtDepth.index = 0;\n    }\n\n    if (updateChildRenderGroups)\n    {\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n        }\n    }\n}\n\nexport function updateRenderGroupTransform(renderGroup: RenderGroup)\n{\n    const root = renderGroup.root;\n\n    let worldAlpha;\n\n    if (renderGroup.renderGroupParent)\n    {\n        const renderGroupParent = renderGroup.renderGroupParent;\n\n        renderGroup.worldTransform.appendFrom(\n            root.relativeGroupTransform,\n            renderGroupParent.worldTransform,\n        );\n\n        renderGroup.worldColor = mixColors(\n            root.groupColor,\n            renderGroupParent.worldColor,\n        );\n\n        worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n    }\n    else\n    {\n        renderGroup.worldTransform.copyFrom(root.localTransform);\n        renderGroup.worldColor = root.localColor;\n        worldAlpha = root.localAlpha;\n    }\n\n    // eslint-disable-next-line no-nested-ternary\n    worldAlpha = worldAlpha < 0 ? 0 : (worldAlpha > 1 ? 1 : worldAlpha);\n    renderGroup.worldAlpha = worldAlpha;\n\n    renderGroup.worldColorAlpha = renderGroup.worldColor\n            + (((worldAlpha * 255) | 0) << 24);\n}\n\nexport function updateTransformAndChildren(container: Container, updateTick: number, updateFlags: number)\n{\n    if (updateTick === container.updateTick) return;\n    container.updateTick = updateTick;\n\n    container.didChange = false;\n\n    const localTransform = container.localTransform;\n\n    container.updateLocalTransform();\n\n    const parent = container.parent;\n\n    if ((parent && !parent.renderGroup))\n    {\n        updateFlags = updateFlags | container._updateFlags;\n\n        container.relativeGroupTransform.appendFrom(\n            localTransform,\n            parent.relativeGroupTransform,\n        );\n\n        if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE)\n        {\n            updateColorBlendVisibility(container, parent, updateFlags);\n        }\n    }\n    else\n    {\n        updateFlags = container._updateFlags;\n\n        container.relativeGroupTransform.copyFrom(localTransform);\n\n        if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE)\n        {\n            updateColorBlendVisibility(container, tempContainer, updateFlags);\n        }\n    }\n\n    // don't update children if its a layer..\n    if (!container.renderGroup)\n    {\n        const children = container.children;\n        const length = children.length;\n\n        for (let i = 0; i < length; i++)\n        {\n            updateTransformAndChildren(children[i], updateTick, updateFlags);\n        }\n\n        const renderGroup = container.parentRenderGroup;\n\n        if (container.renderPipeId && !renderGroup.structureDidChange)\n        {\n            renderGroup.updateRenderable(container);\n        }\n    }\n}\n\nfunction updateColorBlendVisibility(\n    container: Container,\n    parent: Container,\n    updateFlags: number,\n): void\n{\n    if (updateFlags & UPDATE_COLOR)\n    {\n        container.groupColor = mixColors(\n            container.localColor,\n            parent.groupColor\n        );\n\n        let groupAlpha = container.localAlpha * parent.groupAlpha;\n\n        // eslint-disable-next-line no-nested-ternary\n        groupAlpha = groupAlpha < 0 ? 0 : (groupAlpha > 1 ? 1 : groupAlpha);\n\n        container.groupAlpha = groupAlpha;\n        container.groupColorAlpha = container.groupColor + (((groupAlpha * 255) | 0) << 24);\n    }\n\n    if (updateFlags & UPDATE_BLEND)\n    {\n        container.groupBlendMode = container.localBlendMode === 'inherit' ? parent.groupBlendMode : container.localBlendMode;\n    }\n\n    if (updateFlags & UPDATE_VISIBLE)\n    {\n        container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n    }\n\n    container._updateFlags = 0;\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}