{"ast":null,"code":"import { Cache } from '../../../../../assets/cache/Cache.mjs';\nimport { extensions, ExtensionType } from '../../../../../extensions/Extensions.mjs';\nimport { TextureSource } from '../sources/TextureSource.mjs';\nimport { Texture } from '../Texture.mjs';\n\"use strict\";\nconst sources = [];\nextensions.handleByList(ExtensionType.TextureSource, sources);\nfunction autoDetectSource(options = {}) {\n  return textureSourceFrom(options);\n}\nfunction textureSourceFrom(options = {}) {\n  const hasResource = options && options.resource;\n  const res = hasResource ? options.resource : options;\n  const opts = hasResource ? options : {\n    resource: options\n  };\n  for (let i = 0; i < sources.length; i++) {\n    const Source = sources[i];\n    if (Source.test(res)) {\n      return new Source(opts);\n    }\n  }\n  throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\nfunction resourceToTexture(options = {}, skipCache = false) {\n  const hasResource = options && options.resource;\n  const resource = hasResource ? options.resource : options;\n  const opts = hasResource ? options : {\n    resource: options\n  };\n  if (!skipCache && Cache.has(resource)) {\n    return Cache.get(resource);\n  }\n  const texture = new Texture({\n    source: textureSourceFrom(opts)\n  });\n  texture.on(\"destroy\", () => {\n    if (Cache.has(resource)) {\n      Cache.remove(resource);\n    }\n  });\n  if (!skipCache) {\n    Cache.set(resource, texture);\n  }\n  return texture;\n}\nfunction textureFrom(id, skipCache = false) {\n  if (typeof id === \"string\") {\n    return Cache.get(id);\n  } else if (id instanceof TextureSource) {\n    return new Texture({\n      source: id\n    });\n  }\n  return resourceToTexture(id, skipCache);\n}\nTexture.from = textureFrom;\nTextureSource.from = textureSourceFrom;\nexport { autoDetectSource, resourceToTexture, textureFrom };","map":{"version":3,"names":["sources","extensions","handleByList","ExtensionType","TextureSource","autoDetectSource","options","textureSourceFrom","hasResource","resource","res","opts","i","length","Source","test","Error","resourceToTexture","skipCache","Cache","has","get","texture","Texture","source","on","remove","set","textureFrom","id","from"],"sources":["/workspaces/royal-games-updated/node_modules/pixi.js/src/rendering/renderers/shared/texture/utils/textureFrom.ts"],"sourcesContent":["import { Cache } from '../../../../../assets/cache/Cache';\nimport { extensions, ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from '../sources/TextureSource';\nimport { Texture } from '../Texture';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { TypedArray } from '../../buffer/Buffer';\nimport type { BufferSourceOptions } from '../sources/BufferImageSource';\nimport type { CanvasSourceOptions } from '../sources/CanvasSource';\nimport type { ImageResource } from '../sources/ImageSource';\nimport type { TextureSourceOptions } from '../sources/TextureSource';\nimport type { TextureSourceLike } from '../Texture';\n\ninterface TextureSourceConstructor<T extends TextureSource = TextureSource>\n{\n    new (options: TextureSourceOptions): T;\n    test(options: ImageResource | TypedArray | ArrayBuffer | ICanvas): boolean;\n}\n\nconst sources: TextureSourceConstructor[] = [];\n\nextensions.handleByList(ExtensionType.TextureSource, sources);\n\nexport type TextureResourceOrOptions =\n  ImageResource\n  | TextureSourceOptions<ImageResource>\n  | BufferSourceOptions\n  | CanvasSourceOptions;\n\n/**\n * @param options\n * @deprecated since v8.2.0\n * @see TextureSource.from\n */\nexport function autoDetectSource(options: TextureResourceOrOptions = {}): TextureSource\n{\n    return textureSourceFrom(options);\n}\n\n/**\n * Creates a texture source from the options provided\n * @param options - The options to create the texture source from. This can be\n */\nfunction textureSourceFrom(options: TextureResourceOrOptions = {}): TextureSource\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const res = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    for (let i = 0; i < sources.length; i++)\n    {\n        const Source = sources[i];\n\n        if (Source.test(res))\n        {\n            return new Source(opts);\n        }\n    }\n\n    throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\n\nexport function resourceToTexture(\n    options: TextureResourceOrOptions = {},\n    skipCache = false\n): Texture\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const resource = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    if (!skipCache && Cache.has(resource))\n    {\n        return Cache.get(resource);\n    }\n\n    const texture = new Texture({ source: textureSourceFrom(opts) });\n\n    texture.on('destroy', () =>\n    {\n        if (Cache.has(resource))\n        {\n            Cache.remove(resource);\n        }\n    });\n\n    if (!skipCache)\n    {\n        Cache.set(resource, texture);\n    }\n\n    return texture;\n}\n\n/**\n * Helper function that creates a returns Texture based on the source you provide.\n * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n * @param id - String or Source to create texture from\n * @param skipCache - Skip adding the texture to the cache\n * @returns The texture based on the Id provided\n */\nexport function textureFrom(id: TextureSourceLike, skipCache = false): Texture\n{\n    if (typeof id === 'string')\n    {\n        return Cache.get(id);\n    }\n    else if (id instanceof TextureSource)\n    {\n        return new Texture({ source: id });\n    }\n\n    // return a auto generated texture from resource\n    return resourceToTexture(id, skipCache);\n}\n\nTexture.from = textureFrom;\nTextureSource.from = textureSourceFrom;\n"],"mappings":";;;;;AAmBA,MAAMA,OAAA,GAAsC,EAAC;AAE7CC,UAAW,CAAAC,YAAA,CAAaC,aAAc,CAAAC,aAAA,EAAeJ,OAAO;AAa5C,SAAAK,iBAAiBC,OAAoC,KACrE;EACI,OAAOC,iBAAA,CAAkBD,OAAO;AACpC;AAMA,SAASC,kBAAkBD,OAAoC,KAC/D;EACU,MAAAE,WAAA,GAAcF,OAAA,IAAYA,OAAiC,CAAAG,QAAA;EAC3D,MAAAC,GAAA,GAAMF,WAAe,GAAAF,OAAA,CAAiCG,QAAW,GAAAH,OAAA;EACvE,MAAMK,IAAO,GAAAH,WAAA,GAAcF,OAAkC;IAAEG,QAAA,EAAUH;EAAQ;EAEjF,SAASM,CAAI,MAAGA,CAAI,GAAAZ,OAAA,CAAQa,MAAA,EAAQD,CACpC;IACU,MAAAE,MAAA,GAASd,OAAA,CAAQY,CAAC;IAEpB,IAAAE,MAAA,CAAOC,IAAK,CAAAL,GAAG,CACnB;MACW,WAAII,MAAA,CAAOH,IAAI;IAAA;EAC1B;EAGJ,MAAM,IAAIK,KAAA,CAAM,8CAA8CL,IAAA,CAAKF,QAAQ,EAAE;AACjF;AAEO,SAASQ,iBACZA,CAAAX,OAAA,GAAoC,EAAC,EACrCY,SAAA,GAAY,KAEhB;EACU,MAAAV,WAAA,GAAcF,OAAA,IAAYA,OAAiC,CAAAG,QAAA;EAC3D,MAAAA,QAAA,GAAWD,WAAe,GAAAF,OAAA,CAAiCG,QAAW,GAAAH,OAAA;EAC5E,MAAMK,IAAO,GAAAH,WAAA,GAAcF,OAAkC;IAAEG,QAAA,EAAUH;EAAQ;EAEjF,IAAI,CAACY,SAAA,IAAaC,KAAM,CAAAC,GAAA,CAAIX,QAAQ,CACpC;IACW,OAAAU,KAAA,CAAME,GAAA,CAAIZ,QAAQ;EAAA;EAGvB,MAAAa,OAAA,GAAU,IAAIC,OAAQ;IAAEC,MAAA,EAAQjB,iBAAkB,CAAAI,IAAI;EAAA,CAAG;EAEvDW,OAAA,CAAAG,EAAA,CAAG,WAAW,MACtB;IACQ,IAAAN,KAAA,CAAMC,GAAI,CAAAX,QAAQ,CACtB;MACIU,KAAA,CAAMO,MAAA,CAAOjB,QAAQ;IAAA;EACzB,CACH;EAED,IAAI,CAACS,SACL;IACUC,KAAA,CAAAQ,GAAA,CAAIlB,QAAA,EAAUa,OAAO;EAAA;EAGxB,OAAAA,OAAA;AACX;AASgB,SAAAM,YAAYC,EAAuB,EAAAX,SAAA,GAAY,KAC/D;EACQ,WAAOW,EAAA,KAAO,QAClB;IACW,OAAAV,KAAA,CAAME,GAAA,CAAIQ,EAAE;EAAA,CACvB,UACSA,EAAA,YAAczB,aACvB;IACI,OAAO,IAAImB,OAAA,CAAQ;MAAEC,MAAA,EAAQK;IAAA,CAAI;EAAA;EAI9B,OAAAZ,iBAAA,CAAkBY,EAAA,EAAIX,SAAS;AAC1C;AAEAK,OAAA,CAAQO,IAAO,GAAAF,WAAA;AACfxB,aAAA,CAAc0B,IAAO,GAAAvB,iBAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}