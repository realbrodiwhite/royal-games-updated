{"ast":null,"code":"import { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet.mjs';\n\"use strict\";\nclass RenderGroup {\n  constructor() {\n    this.renderPipeId = \"renderGroup\";\n    this.root = null;\n    this.canBundle = false;\n    this.renderGroupParent = null;\n    this.renderGroupChildren = [];\n    this.worldTransform = new Matrix();\n    this.worldColorAlpha = 4294967295;\n    this.worldColor = 16777215;\n    this.worldAlpha = 1;\n    // these updates are transform changes..\n    this.childrenToUpdate = /* @__PURE__ */Object.create(null);\n    this.updateTick = 0;\n    // these update are renderable changes..\n    this.childrenRenderablesToUpdate = {\n      list: [],\n      index: 0\n    };\n    // other\n    this.structureDidChange = true;\n    this.instructionSet = new InstructionSet();\n    this._onRenderContainers = [];\n  }\n  init(root) {\n    this.root = root;\n    if (root._onRender) this.addOnRender(root);\n    root.didChange = true;\n    const children = root.children;\n    for (let i = 0; i < children.length; i++) {\n      this.addChild(children[i]);\n    }\n  }\n  reset() {\n    this.renderGroupChildren.length = 0;\n    for (const i in this.childrenToUpdate) {\n      const childrenAtDepth = this.childrenToUpdate[i];\n      childrenAtDepth.list.fill(null);\n      childrenAtDepth.index = 0;\n    }\n    this.childrenRenderablesToUpdate.index = 0;\n    this.childrenRenderablesToUpdate.list.fill(null);\n    this.root = null;\n    this.updateTick = 0;\n    this.structureDidChange = true;\n    this._onRenderContainers.length = 0;\n    this.renderGroupParent = null;\n  }\n  get localTransform() {\n    return this.root.localTransform;\n  }\n  addRenderGroupChild(renderGroupChild) {\n    if (renderGroupChild.renderGroupParent) {\n      renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n    }\n    renderGroupChild.renderGroupParent = this;\n    this.renderGroupChildren.push(renderGroupChild);\n  }\n  _removeRenderGroupChild(renderGroupChild) {\n    const index = this.renderGroupChildren.indexOf(renderGroupChild);\n    if (index > -1) {\n      this.renderGroupChildren.splice(index, 1);\n    }\n    renderGroupChild.renderGroupParent = null;\n  }\n  addChild(child) {\n    this.structureDidChange = true;\n    child.parentRenderGroup = this;\n    child.updateTick = -1;\n    if (child.parent === this.root) {\n      child.relativeRenderGroupDepth = 1;\n    } else {\n      child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n    }\n    child.didChange = true;\n    this.onChildUpdate(child);\n    if (child.renderGroup) {\n      this.addRenderGroupChild(child.renderGroup);\n      return;\n    }\n    if (child._onRender) this.addOnRender(child);\n    const children = child.children;\n    for (let i = 0; i < children.length; i++) {\n      this.addChild(children[i]);\n    }\n  }\n  removeChild(child) {\n    this.structureDidChange = true;\n    if (child._onRender) {\n      if (!child.renderGroup) {\n        this.removeOnRender(child);\n      }\n    }\n    child.parentRenderGroup = null;\n    if (child.renderGroup) {\n      this._removeRenderGroupChild(child.renderGroup);\n      return;\n    }\n    const children = child.children;\n    for (let i = 0; i < children.length; i++) {\n      this.removeChild(children[i]);\n    }\n  }\n  removeChildren(children) {\n    for (let i = 0; i < children.length; i++) {\n      this.removeChild(children[i]);\n    }\n  }\n  onChildUpdate(child) {\n    let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n    if (!childrenToUpdate) {\n      childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n        index: 0,\n        list: []\n      };\n    }\n    childrenToUpdate.list[childrenToUpdate.index++] = child;\n  }\n  // SHOULD THIS BE HERE?\n  updateRenderable(container) {\n    if (container.globalDisplayStatus < 7) return;\n    container.didViewUpdate = false;\n    this.instructionSet.renderPipes[container.renderPipeId].updateRenderable(container);\n  }\n  onChildViewUpdate(child) {\n    this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n  }\n  get isRenderable() {\n    return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;\n  }\n  /**\n   * adding a container to the onRender list will make sure the user function\n   * passed in to the user defined 'onRender` callBack\n   * @param container - the container to add to the onRender list\n   */\n  addOnRender(container) {\n    this._onRenderContainers.push(container);\n  }\n  removeOnRender(container) {\n    this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n  }\n  runOnRender() {\n    for (let i = 0; i < this._onRenderContainers.length; i++) {\n      this._onRenderContainers[i]._onRender();\n    }\n  }\n  destroy() {\n    this.renderGroupParent = null;\n    this.root = null;\n    this.childrenRenderablesToUpdate = null;\n    this.childrenToUpdate = null;\n    this.renderGroupChildren = null;\n    this._onRenderContainers = null;\n    this.instructionSet = null;\n  }\n  getChildren(out = []) {\n    const children = this.root.children;\n    for (let i = 0; i < children.length; i++) {\n      this._getChildren(children[i], out);\n    }\n    return out;\n  }\n  _getChildren(container, out = []) {\n    out.push(container);\n    if (container.renderGroup) return out;\n    const children = container.children;\n    for (let i = 0; i < children.length; i++) {\n      this._getChildren(children[i], out);\n    }\n    return out;\n  }\n}\nexport { RenderGroup };","map":{"version":3,"names":["RenderGroup","constructor","renderPipeId","root","canBundle","renderGroupParent","renderGroupChildren","worldTransform","Matrix","worldColorAlpha","worldColor","worldAlpha","childrenToUpdate","Object","create","updateTick","childrenRenderablesToUpdate","list","index","structureDidChange","instructionSet","InstructionSet","_onRenderContainers","init","_onRender","addOnRender","didChange","children","i","length","addChild","reset","childrenAtDepth","fill","localTransform","addRenderGroupChild","renderGroupChild","_removeRenderGroupChild","push","indexOf","splice","child","parentRenderGroup","parent","relativeRenderGroupDepth","onChildUpdate","renderGroup","removeChild","removeOnRender","removeChildren","updateRenderable","container","globalDisplayStatus","didViewUpdate","renderPipes","onChildViewUpdate","isRenderable","localDisplayStatus","runOnRender","destroy","getChildren","out","_getChildren"],"sources":["/workspaces/royal-games-updated/node_modules/pixi.js/src/scene/container/RenderGroup.ts"],"sourcesContent":["import { Matrix } from '../../maths/matrix/Matrix';\nimport { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\n\nimport type { Instruction } from '../../rendering/renderers/shared/instructions/Instruction';\nimport type { Container } from './Container';\n\n/**\n * A RenderGroup is a class that is responsible for I generating a set of instructions that are used to render the\n * root container and its children. It also watches for any changes in that container or its children,\n * these changes are analysed and either the instruction set is rebuild or the instructions data is updated.\n * @memberof rendering\n */\nexport class RenderGroup implements Instruction\n{\n    public renderPipeId = 'renderGroup';\n    public root: Container = null;\n\n    public canBundle = false;\n\n    public renderGroupParent: RenderGroup = null;\n    public renderGroupChildren: RenderGroup[] = [];\n\n    public worldTransform: Matrix = new Matrix();\n    public worldColorAlpha = 0xffffffff;\n    public worldColor = 0xffffff;\n    public worldAlpha = 1;\n\n    // these updates are transform changes..\n    public readonly childrenToUpdate: Record<number, { list: Container[]; index: number; }> = Object.create(null);\n    public updateTick = 0;\n\n    // these update are renderable changes..\n    public readonly childrenRenderablesToUpdate: { list: Container[]; index: number; } = { list: [], index: 0 };\n\n    // other\n    public structureDidChange = true;\n\n    public instructionSet: InstructionSet = new InstructionSet();\n\n    private readonly _onRenderContainers: Container[] = [];\n\n    public init(root: Container)\n    {\n        this.root = root;\n\n        if (root._onRender) this.addOnRender(root);\n\n        root.didChange = true;\n\n        const children = root.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.addChild(children[i]);\n        }\n    }\n\n    public reset()\n    {\n        this.renderGroupChildren.length = 0;\n\n        for (const i in this.childrenToUpdate)\n        {\n            const childrenAtDepth = this.childrenToUpdate[i];\n\n            childrenAtDepth.list.fill(null);\n            childrenAtDepth.index = 0;\n        }\n\n        this.childrenRenderablesToUpdate.index = 0;\n        this.childrenRenderablesToUpdate.list.fill(null);\n\n        this.root = null;\n        this.updateTick = 0;\n        this.structureDidChange = true;\n\n        this._onRenderContainers.length = 0;\n        this.renderGroupParent = null;\n    }\n\n    get localTransform()\n    {\n        return this.root.localTransform;\n    }\n\n    public addRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        if (renderGroupChild.renderGroupParent)\n        {\n            renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n        }\n\n        renderGroupChild.renderGroupParent = this;\n\n        this.renderGroupChildren.push(renderGroupChild);\n    }\n\n    private _removeRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        const index = this.renderGroupChildren.indexOf(renderGroupChild);\n\n        if (index > -1)\n        {\n            this.renderGroupChildren.splice(index, 1);\n        }\n\n        renderGroupChild.renderGroupParent = null;\n    }\n\n    public addChild(child: Container)\n    {\n        this.structureDidChange = true;\n\n        child.parentRenderGroup = this;\n\n        child.updateTick = -1;\n\n        if (child.parent === this.root)\n        {\n            child.relativeRenderGroupDepth = 1;\n        }\n        else\n        {\n            child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n        }\n\n        child.didChange = true;\n        this.onChildUpdate(child);\n\n        if (child.renderGroup)\n        {\n            this.addRenderGroupChild(child.renderGroup);\n\n            return;\n        }\n\n        if (child._onRender) this.addOnRender(child);\n\n        const children = child.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.addChild(children[i]);\n        }\n    }\n\n    public removeChild(child: Container)\n    {\n        // remove all the children...\n        this.structureDidChange = true;\n\n        if (child._onRender)\n        {\n            // Remove the child to the onRender list under the following conditions:\n            // 1. If the child is not a render group.\n            // 2. If the child is a render group root of this render group - which it can't be removed from in this case.\n            if (!child.renderGroup)\n            {\n                this.removeOnRender(child);\n            }\n        }\n\n        child.parentRenderGroup = null;\n\n        if (child.renderGroup)\n        {\n            this._removeRenderGroupChild(child.renderGroup);\n\n            return;\n        }\n\n        const children = child.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.removeChild(children[i]);\n        }\n    }\n\n    public removeChildren(children: Container[])\n    {\n        for (let i = 0; i < children.length; i++)\n        {\n            this.removeChild(children[i]);\n        }\n    }\n\n    public onChildUpdate(child: Container)\n    {\n        let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n\n        if (!childrenToUpdate)\n        {\n            childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n                index: 0,\n                list: [],\n            };\n        }\n\n        childrenToUpdate.list[childrenToUpdate.index++] = child;\n    }\n\n    // SHOULD THIS BE HERE?\n    public updateRenderable(container: Container)\n    {\n        // only update if its visible!\n        if (container.globalDisplayStatus < 0b111) return;\n\n        container.didViewUpdate = false;\n        // actually updates the renderable..\n        this.instructionSet.renderPipes[container.renderPipeId].updateRenderable(container);\n    }\n\n    public onChildViewUpdate(child: Container)\n    {\n        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n    }\n\n    get isRenderable(): boolean\n    {\n        return (this.root.localDisplayStatus === 0b111 && this.worldAlpha > 0);\n    }\n\n    /**\n     * adding a container to the onRender list will make sure the user function\n     * passed in to the user defined 'onRender` callBack\n     * @param container - the container to add to the onRender list\n     */\n    public addOnRender(container: Container)\n    {\n        this._onRenderContainers.push(container);\n    }\n\n    public removeOnRender(container: Container)\n    {\n        this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n    }\n\n    public runOnRender()\n    {\n        for (let i = 0; i < this._onRenderContainers.length; i++)\n        {\n            this._onRenderContainers[i]._onRender();\n        }\n    }\n\n    public destroy()\n    {\n        this.renderGroupParent = null;\n        this.root = null;\n        (this.childrenRenderablesToUpdate as any) = null;\n        (this.childrenToUpdate as any) = null;\n        (this.renderGroupChildren as any) = null;\n        (this._onRenderContainers as any) = null;\n        this.instructionSet = null;\n    }\n\n    public getChildren(out: Container[] = []): Container[]\n    {\n        const children = this.root.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this._getChildren(children[i], out);\n        }\n\n        return out;\n    }\n\n    private _getChildren(container: Container, out: Container[] = []): Container[]\n    {\n        out.push(container);\n\n        if (container.renderGroup) return out;\n\n        const children = container.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this._getChildren(children[i], out);\n        }\n\n        return out;\n    }\n}\n"],"mappings":";;;AAYO,MAAMA,WACb;EADOC,YAAA;IAEH,KAAOC,YAAe;IACtB,KAAOC,IAAkB;IAEzB,KAAOC,SAAY;IAEnB,KAAOC,iBAAiC;IACxC,KAAOC,mBAAA,GAAqC,EAAC;IAEtC,KAAAC,cAAA,GAAyB,IAAIC,MAAO;IAC3C,KAAOC,eAAkB;IACzB,KAAOC,UAAa;IACpB,KAAOC,UAAa;IAGpB;IAAgB,KAAAC,gBAAA,kBAAiFC,MAAA,CAAAC,MAAA,CAAO,IAAI;IAC5G,KAAOC,UAAa;IAGpB;IAAA,KAAgBC,2BAAA,GAAqE;MAAEC,IAAA,EAAM,EAAC;MAAGC,KAAA,EAAO;IAAE;IAG1G;IAAA,KAAOC,kBAAqB;IAErB,KAAAC,cAAA,GAAiC,IAAIC,cAAe;IAE3D,KAAiBC,mBAAA,GAAmC,EAAC;EAAA;EAE9CC,KAAKpB,IACZ;IACI,KAAKA,IAAO,GAAAA,IAAA;IAEZ,IAAIA,IAAK,CAAAqB,SAAA,EAAW,KAAKC,WAAA,CAAYtB,IAAI;IAEzCA,IAAA,CAAKuB,SAAY;IAEjB,MAAMC,QAAA,GAAWxB,IAAK,CAAAwB,QAAA;IAEtB,SAASC,CAAI,MAAGA,CAAI,GAAAD,QAAA,CAASE,MAAA,EAAQD,CACrC;MACS,KAAAE,QAAA,CAASH,QAAS,CAAAC,CAAC,CAAC;IAAA;EAC7B;EAGGG,KACPA,CAAA;IACI,KAAKzB,mBAAA,CAAoBuB,MAAS;IAEvB,WAAAD,CAAA,IAAK,KAAKhB,gBACrB;MACU,MAAAoB,eAAA,GAAkB,IAAK,CAAApB,gBAAA,CAAiBgB,CAAC;MAE/BI,eAAA,CAAAf,IAAA,CAAKgB,IAAA,CAAK,IAAI;MAC9BD,eAAA,CAAgBd,KAAQ;IAAA;IAG5B,KAAKF,2BAAA,CAA4BE,KAAQ;IACpC,KAAAF,2BAAA,CAA4BC,IAAK,CAAAgB,IAAA,CAAK,IAAI;IAE/C,KAAK9B,IAAO;IACZ,KAAKY,UAAa;IAClB,KAAKI,kBAAqB;IAE1B,KAAKG,mBAAA,CAAoBO,MAAS;IAClC,KAAKxB,iBAAoB;EAAA;EAG7B,IAAI6B,cACJA,CAAA;IACI,OAAO,KAAK/B,IAAK,CAAA+B,cAAA;EAAA;EAGdC,oBAAoBC,gBAC3B;IACI,IAAIA,gBAAA,CAAiB/B,iBACrB;MACqB+B,gBAAA,CAAA/B,iBAAA,CAAkBgC,uBAAA,CAAwBD,gBAAgB;IAAA;IAG/EA,gBAAA,CAAiB/B,iBAAoB;IAEhC,KAAAC,mBAAA,CAAoBgC,IAAA,CAAKF,gBAAgB;EAAA;EAG1CC,wBAAwBD,gBAChC;IACI,MAAMlB,KAAQ,QAAKZ,mBAAoB,CAAAiC,OAAA,CAAQH,gBAAgB;IAE/D,IAAIlB,KAAA,GAAQ,CACZ;MACS,KAAAZ,mBAAA,CAAoBkC,MAAO,CAAAtB,KAAA,EAAO,CAAC;IAAA;IAG5CkB,gBAAA,CAAiB/B,iBAAoB;EAAA;EAGlCyB,SAASW,KAChB;IACI,KAAKtB,kBAAqB;IAE1BsB,KAAA,CAAMC,iBAAoB;IAE1BD,KAAA,CAAM1B,UAAa;IAEf,IAAA0B,KAAA,CAAME,MAAW,UAAKxC,IAC1B;MACIsC,KAAA,CAAMG,wBAA2B;IAAA,CAGrC;MACUH,KAAA,CAAAG,wBAAA,GAA2BH,KAAM,CAAAE,MAAA,CAAOC,wBAA2B;IAAA;IAG7EH,KAAA,CAAMf,SAAY;IAClB,KAAKmB,aAAA,CAAcJ,KAAK;IAExB,IAAIA,KAAA,CAAMK,WACV;MACS,KAAAX,mBAAA,CAAoBM,KAAA,CAAMK,WAAW;MAE1C;IAAA;IAGJ,IAAIL,KAAM,CAAAjB,SAAA,EAAW,KAAKC,WAAA,CAAYgB,KAAK;IAE3C,MAAMd,QAAA,GAAWc,KAAM,CAAAd,QAAA;IAEvB,SAASC,CAAI,MAAGA,CAAI,GAAAD,QAAA,CAASE,MAAA,EAAQD,CACrC;MACS,KAAAE,QAAA,CAASH,QAAS,CAAAC,CAAC,CAAC;IAAA;EAC7B;EAGGmB,YAAYN,KACnB;IAEI,KAAKtB,kBAAqB;IAE1B,IAAIsB,KAAA,CAAMjB,SACV;MAIQ,KAACiB,KAAA,CAAMK,WACX;QACI,KAAKE,cAAA,CAAeP,KAAK;MAAA;IAC7B;IAGJA,KAAA,CAAMC,iBAAoB;IAE1B,IAAID,KAAA,CAAMK,WACV;MACS,KAAAT,uBAAA,CAAwBI,KAAA,CAAMK,WAAW;MAE9C;IAAA;IAGJ,MAAMnB,QAAA,GAAWc,KAAM,CAAAd,QAAA;IAEvB,SAASC,CAAI,MAAGA,CAAI,GAAAD,QAAA,CAASE,MAAA,EAAQD,CACrC;MACS,KAAAmB,WAAA,CAAYpB,QAAS,CAAAC,CAAC,CAAC;IAAA;EAChC;EAGGqB,eAAetB,QACtB;IACI,SAASC,CAAI,MAAGA,CAAI,GAAAD,QAAA,CAASE,MAAA,EAAQD,CACrC;MACS,KAAAmB,WAAA,CAAYpB,QAAS,CAAAC,CAAC,CAAC;IAAA;EAChC;EAGGiB,cAAcJ,KACrB;IACI,IAAI7B,gBAAmB,QAAKA,gBAAiB,CAAA6B,KAAA,CAAMG,wBAAwB;IAE3E,IAAI,CAAChC,gBACL;MACIA,gBAAA,GAAmB,IAAK,CAAAA,gBAAA,CAAiB6B,KAAM,CAAAG,wBAAwB,CAAI;QACvE1B,KAAO;QACPD,IAAA,EAAM;MAAC,CACX;IAAA;IAGaL,gBAAA,CAAAK,IAAA,CAAKL,gBAAiB,CAAAM,KAAA,EAAO,CAAI,GAAAuB,KAAA;EAAA;EACtD;EAGOS,iBAAiBC,SACxB;IAEI,IAAIA,SAAA,CAAUC,mBAAsB,MAAO;IAE3CD,SAAA,CAAUE,aAAgB;IAE1B,KAAKjC,cAAA,CAAekC,WAAY,CAAAH,SAAA,CAAUjD,YAAY,EAAEgD,gBAAA,CAAiBC,SAAS;EAAA;EAG/EI,kBAAkBd,KACzB;IACI,KAAKzB,2BAA4B,CAAAC,IAAA,CAAK,IAAK,CAAAD,2BAAA,CAA4BE,KAAA,EAAO,CAAI,GAAAuB,KAAA;EAAA;EAGtF,IAAIe,YACJA,CAAA;IACI,OAAQ,IAAK,CAAArD,IAAA,CAAKsD,kBAAuB,UAAS,KAAK9C,UAAa;EAAA;EACxE;AAAA;AAAA;AAAA;AAAA;EAOOc,YAAY0B,SACnB;IACS,KAAA7B,mBAAA,CAAoBgB,IAAA,CAAKa,SAAS;EAAA;EAGpCH,eAAeG,SACtB;IACI,KAAK7B,mBAAA,CAAoBkB,MAAO,MAAKlB,mBAAA,CAAoBiB,OAAQ,CAAAY,SAAS,GAAG,CAAC;EAAA;EAG3EO,WACPA,CAAA;IACI,SAAS9B,CAAA,GAAI,CAAG,EAAAA,CAAA,GAAI,IAAK,CAAAN,mBAAA,CAAoBO,MAAA,EAAQD,CACrD;MACS,KAAAN,mBAAA,CAAoBM,CAAC,EAAEJ,SAAU;IAAA;EAC1C;EAGGmC,OACPA,CAAA;IACI,KAAKtD,iBAAoB;IACzB,KAAKF,IAAO;IACX,KAAKa,2BAAsC;IAC3C,KAAKJ,gBAA2B;IAChC,KAAKN,mBAA8B;IACnC,KAAKgB,mBAA8B;IACpC,KAAKF,cAAiB;EAAA;EAGnBwC,YAAYC,GAAmB,KACtC;IACU,MAAAlC,QAAA,GAAW,KAAKxB,IAAK,CAAAwB,QAAA;IAE3B,SAASC,CAAI,MAAGA,CAAI,GAAAD,QAAA,CAASE,MAAA,EAAQD,CACrC;MACI,KAAKkC,YAAa,CAAAnC,QAAA,CAASC,CAAC,GAAGiC,GAAG;IAAA;IAG/B,OAAAA,GAAA;EAAA;EAGHC,YAAaA,CAAAX,SAAA,EAAsBU,GAAmB,KAC9D;IACIA,GAAA,CAAIvB,IAAA,CAAKa,SAAS;IAElB,IAAIA,SAAU,CAAAL,WAAA,EAAoB,OAAAe,GAAA;IAElC,MAAMlC,QAAA,GAAWwB,SAAU,CAAAxB,QAAA;IAE3B,SAASC,CAAI,MAAGA,CAAI,GAAAD,QAAA,CAASE,MAAA,EAAQD,CACrC;MACI,KAAKkC,YAAa,CAAAnC,QAAA,CAASC,CAAC,GAAGiC,GAAG;IAAA;IAG/B,OAAAA,GAAA;EAAA;AAEf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}