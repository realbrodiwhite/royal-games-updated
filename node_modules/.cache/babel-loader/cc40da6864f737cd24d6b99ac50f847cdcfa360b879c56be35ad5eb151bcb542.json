{"ast":null,"code":"import { Color } from '../../../../color/Color.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { FillGradient } from '../fill/FillGradient.mjs';\nimport { FillPattern } from '../fill/FillPattern.mjs';\n\"use strict\";\nfunction isColorLike(value) {\n  return Color.isColorLike(value);\n}\nfunction isFillPattern(value) {\n  return value instanceof FillPattern;\n}\nfunction isFillGradient(value) {\n  return value instanceof FillGradient;\n}\nfunction handleColorLike(fill, value, defaultStyle) {\n  const temp = Color.shared.setValue(value ?? 0);\n  fill.color = temp.toNumber();\n  fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;\n  fill.texture = Texture.WHITE;\n  return {\n    ...defaultStyle,\n    ...fill\n  };\n}\nfunction handleFillPattern(fill, value, defaultStyle) {\n  fill.fill = value;\n  fill.color = 16777215;\n  fill.texture = value.texture;\n  fill.matrix = value.transform;\n  return {\n    ...defaultStyle,\n    ...fill\n  };\n}\nfunction handleFillGradient(fill, value, defaultStyle) {\n  value.buildLinearGradient();\n  fill.fill = value;\n  fill.color = 16777215;\n  fill.texture = value.texture;\n  fill.matrix = value.transform;\n  return {\n    ...defaultStyle,\n    ...fill\n  };\n}\nfunction handleFillObject(value, defaultStyle) {\n  const style = {\n    ...defaultStyle,\n    ...value\n  };\n  if (style.texture) {\n    if (style.texture !== Texture.WHITE) {\n      const m = style.matrix?.invert() || new Matrix();\n      m.translate(style.texture.frame.x, style.texture.frame.y);\n      m.scale(1 / style.texture.source.width, 1 / style.texture.source.height);\n      style.matrix = m;\n    }\n    const sourceStyle = style.texture.source.style;\n    if (sourceStyle.addressMode === \"clamp-to-edge\") {\n      sourceStyle.addressMode = \"repeat\";\n      sourceStyle.update();\n    }\n  }\n  const color = Color.shared.setValue(style.color);\n  style.alpha *= color.alpha;\n  style.color = color.toNumber();\n  style.matrix = style.matrix ? style.matrix.clone() : null;\n  return style;\n}\nfunction toFillStyle(value, defaultStyle) {\n  if (value === void 0 || value === null) {\n    return null;\n  }\n  const fill = {};\n  const objectStyle = value;\n  if (isColorLike(value)) {\n    return handleColorLike(fill, value, defaultStyle);\n  } else if (isFillPattern(value)) {\n    return handleFillPattern(fill, value, defaultStyle);\n  } else if (isFillGradient(value)) {\n    return handleFillGradient(fill, value, defaultStyle);\n  } else if (objectStyle.fill && isFillPattern(objectStyle.fill)) {\n    return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);\n  } else if (objectStyle.fill && isFillGradient(objectStyle.fill)) {\n    return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);\n  }\n  return handleFillObject(objectStyle, defaultStyle);\n}\nfunction toStrokeStyle(value, defaultStyle) {\n  const {\n    width,\n    alignment,\n    miterLimit,\n    cap,\n    join,\n    ...rest\n  } = defaultStyle;\n  const fill = toFillStyle(value, rest);\n  if (!fill) {\n    return null;\n  }\n  return {\n    width,\n    alignment,\n    miterLimit,\n    cap,\n    join,\n    ...fill\n  };\n}\nexport { toFillStyle, toStrokeStyle };","map":{"version":3,"names":["isColorLike","value","Color","isFillPattern","FillPattern","isFillGradient","FillGradient","handleColorLike","fill","defaultStyle","temp","shared","setValue","color","toNumber","alpha","texture","Texture","WHITE","handleFillPattern","matrix","transform","handleFillGradient","buildLinearGradient","handleFillObject","style","m","invert","Matrix","translate","frame","x","y","scale","source","width","height","sourceStyle","addressMode","update","clone","toFillStyle","objectStyle","toStrokeStyle","alignment","miterLimit","cap","join","rest"],"sources":["/workspaces/royal-games-updated/node_modules/pixi.js/src/scene/graphics/shared/utils/convertFillInputToFillStyle.ts"],"sourcesContent":["import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { FillGradient } from '../fill/FillGradient';\nimport { FillPattern } from '../fill/FillPattern';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillInput,\n    FillStyle,\n    StrokeInput,\n} from '../FillTypes';\n\nfunction isColorLike(value: unknown): value is ColorSource\n{\n    return Color.isColorLike(value as ColorSource);\n}\n\nfunction isFillPattern(value: unknown): value is FillPattern\n{\n    return value instanceof FillPattern;\n}\n\nfunction isFillGradient(value: unknown): value is FillGradient\n{\n    return value instanceof FillGradient;\n}\n\n/**\n * Handles the case where the value is a ColorLike\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(0xff0000)\n * graphics.fill(new Color(0xff0000))\n * graphics.fill({ r: 255, g: 0, b: 0 })\n */\nfunction handleColorLike(\n    fill: FillStyle,\n    value: ColorSource,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    const temp = Color.shared.setValue(value ?? 0);\n\n    fill.color = temp.toNumber();\n    fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;\n    fill.texture = Texture.WHITE;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is a FillPattern\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(new FillPattern(0xff0000))\n */\nfunction handleFillPattern(\n    fill: FillStyle,\n    value: FillPattern,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    fill.fill = value;\n    fill.color = 0xffffff;\n    fill.texture = value.texture;\n    fill.matrix = value.transform;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is a FillGradient\n * @param fill\n * @param value\n * @param defaultStyle\n * @example\n * graphics.fill(new FillGradient(0, 0, 200, 0))\n */\nfunction handleFillGradient(\n    fill: FillStyle,\n    value: FillGradient,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    value.buildLinearGradient();\n    fill.fill = value;\n    fill.color = 0xffffff;\n    fill.texture = value.texture;\n    fill.matrix = value.transform;\n\n    return { ...defaultStyle, ...fill } as ConvertedFillStyle;\n}\n\n/**\n * Handles the case where the value is not a direct Pixi Color, PatternFill, or GradientFill but instead\n * an object with potentially `color`\n * @example\n * {\n *   color: new Color(0xff0000)\n *   alpha: 0.5,\n *   texture?: null,\n *   matrix?: null,\n * }\n * @param value\n * @param defaultStyle\n */\nfunction handleFillObject(value: FillStyle, defaultStyle: ConvertedFillStyle): ConvertedFillStyle\n{\n    const style = { ...defaultStyle, ...(value as FillStyle) };\n\n    if (style.texture)\n    {\n        if (style.texture !== Texture.WHITE)\n        {\n            const m = style.matrix?.invert() || new Matrix();\n\n            m.translate(style.texture.frame.x, style.texture.frame.y);\n            m.scale(1 / style.texture.source.width, 1 / style.texture.source.height);\n\n            style.matrix = m;\n        }\n\n        const sourceStyle = style.texture.source.style;\n\n        if (sourceStyle.addressMode === 'clamp-to-edge')\n        {\n            sourceStyle.addressMode = 'repeat';\n            sourceStyle.update();\n        }\n    }\n\n    const color = Color.shared.setValue(style.color);\n\n    style.alpha *= color.alpha;\n    style.color = color.toNumber();\n    style.matrix = style.matrix ? style.matrix.clone() : null; // todo: lets optimise this!\n\n    return style as ConvertedFillStyle;\n}\n\n/**\n * Converts a value to a fill style, we do this as PixiJS has a number of ways to define a fill style\n * They can be a direct color, a texture, a gradient, or an object with these values in them\n * This function will take any of these input types and convert them into a single object\n * that PixiJS can understand and use internally.\n * @param value - The value to convert to a fill style\n * @param defaultStyle - The default fill style to use\n * @private\n */\nexport function toFillStyle<T extends FillInput>(\n    value: T,\n    defaultStyle: ConvertedFillStyle\n): ConvertedFillStyle\n{\n    if (value === undefined || value === null)\n    {\n        return null;\n    }\n\n    const fill: ConvertedFillStyle = {} as ConvertedFillStyle;\n    const objectStyle = value as FillStyle;\n\n    if (isColorLike(value))\n    {\n        return handleColorLike(fill, value, defaultStyle);\n    }\n    else if (isFillPattern(value))\n    {\n        return handleFillPattern(fill, value, defaultStyle);\n    }\n    else if (isFillGradient(value))\n    {\n        return handleFillGradient(fill, value, defaultStyle);\n    }\n    else if (objectStyle.fill && isFillPattern(objectStyle.fill))\n    {\n        return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);\n    }\n    else if (objectStyle.fill && isFillGradient(objectStyle.fill))\n    {\n        return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);\n    }\n\n    return handleFillObject(objectStyle, defaultStyle);\n}\n\n/**\n * Converts a value to a stroke style, similar to `toFillStyle` but for strokes\n * @param value - The value to convert to a stroke style\n * @param defaultStyle - The default stroke style to use\n * @private\n */\nexport function toStrokeStyle(value: StrokeInput, defaultStyle: ConvertedStrokeStyle): ConvertedStrokeStyle\n{\n    const { width, alignment, miterLimit, cap, join, ...rest } = defaultStyle;\n    const fill = toFillStyle(value, rest);\n\n    if (!fill)\n    {\n        return null;\n    }\n\n    return {\n        width,\n        alignment,\n        miterLimit,\n        cap,\n        join,\n        ...fill,\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}