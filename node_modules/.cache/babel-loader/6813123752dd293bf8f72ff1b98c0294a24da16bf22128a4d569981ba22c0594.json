{"ast":null,"code":"import { extensions, ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { buildUvs, buildSimpleUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs.mjs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices.mjs';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture.mjs';\nimport { BigPool } from '../../../../utils/pool/PoolGroup.mjs';\nimport { BatchableGraphics } from '../BatchableGraphics.mjs';\nimport { buildCircle, buildEllipse, buildRoundedRectangle } from '../buildCommands/buildCircle.mjs';\nimport { buildLine } from '../buildCommands/buildLine.mjs';\nimport { buildPolygon } from '../buildCommands/buildPolygon.mjs';\nimport { buildRectangle } from '../buildCommands/buildRectangle.mjs';\nimport { buildTriangle } from '../buildCommands/buildTriangle.mjs';\nimport { triangulateWithHoles } from './triangulateWithHoles.mjs';\n\"use strict\";\nconst shapeBuilders = {};\nextensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);\nextensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);\nconst tempRect = new Rectangle();\nfunction buildContextBatches(context, gpuContext) {\n  const {\n    geometryData,\n    batches\n  } = gpuContext;\n  batches.length = 0;\n  geometryData.indices.length = 0;\n  geometryData.vertices.length = 0;\n  geometryData.uvs.length = 0;\n  for (let i = 0; i < context.instructions.length; i++) {\n    const instruction = context.instructions[i];\n    if (instruction.action === \"texture\") {\n      addTextureToGeometryData(instruction.data, batches, geometryData);\n    } else if (instruction.action === \"fill\" || instruction.action === \"stroke\") {\n      const isStroke = instruction.action === \"stroke\";\n      const shapePath = instruction.data.path.shapePath;\n      const style = instruction.data.style;\n      const hole = instruction.data.hole;\n      if (isStroke && hole) {\n        addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n      }\n      addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n    }\n  }\n}\nfunction addTextureToGeometryData(data, batches, geometryData) {\n  const {\n    vertices,\n    uvs,\n    indices\n  } = geometryData;\n  const indexOffset = indices.length;\n  const vertOffset = vertices.length / 2;\n  const points = [];\n  const build = shapeBuilders.rectangle;\n  const rect = tempRect;\n  const texture = data.image;\n  rect.x = data.dx;\n  rect.y = data.dy;\n  rect.width = data.dw;\n  rect.height = data.dh;\n  const matrix = data.transform;\n  build.build(rect, points);\n  if (matrix) {\n    transformVertices(points, matrix);\n  }\n  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n  const textureUvs = texture.uvs;\n  uvs.push(textureUvs.x0, textureUvs.y0, textureUvs.x1, textureUvs.y1, textureUvs.x3, textureUvs.y3, textureUvs.x2, textureUvs.y2);\n  const graphicsBatch = BigPool.get(BatchableGraphics);\n  graphicsBatch.indexOffset = indexOffset;\n  graphicsBatch.indexSize = indices.length - indexOffset;\n  graphicsBatch.attributeOffset = vertOffset;\n  graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;\n  graphicsBatch.baseColor = data.style;\n  graphicsBatch.alpha = data.alpha;\n  graphicsBatch.texture = texture;\n  graphicsBatch.geometryData = geometryData;\n  batches.push(graphicsBatch);\n}\nfunction addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData) {\n  const {\n    vertices,\n    uvs,\n    indices\n  } = geometryData;\n  const lastIndex = shapePath.shapePrimitives.length - 1;\n  shapePath.shapePrimitives.forEach((_ref, i) => {\n    let {\n      shape,\n      transform: matrix\n    } = _ref;\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n    const points = [];\n    const build = shapeBuilders[shape.type];\n    build.build(shape, points);\n    if (matrix) {\n      transformVertices(points, matrix);\n    }\n    if (!isStroke) {\n      if (hole && lastIndex === i) {\n        if (lastIndex !== 0) {\n          console.warn(\"[Pixi Graphics] only the last shape have be cut out\");\n        }\n        const holeIndices = [];\n        const otherPoints = points.slice();\n        const holeArrays = getHoleArrays(hole.shapePath);\n        holeArrays.forEach(holePoints => {\n          holeIndices.push(otherPoints.length / 2);\n          otherPoints.push(...holePoints);\n        });\n        triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n      } else {\n        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n      }\n    } else {\n      const close = shape.closePath ?? true;\n      const lineStyle = style;\n      buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);\n    }\n    const uvsOffset = uvs.length / 2;\n    const texture = style.texture;\n    if (texture !== Texture.WHITE) {\n      const textureMatrix = style.matrix;\n      if (textureMatrix) {\n        if (matrix) {\n          textureMatrix.append(matrix.clone().invert());\n        }\n        buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);\n      }\n    } else {\n      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);\n    }\n    const graphicsBatch = BigPool.get(BatchableGraphics);\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n    graphicsBatch.attributeOffset = vertOffset;\n    graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;\n    graphicsBatch.baseColor = style.color;\n    graphicsBatch.alpha = style.alpha;\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n    batches.push(graphicsBatch);\n  });\n}\nfunction getHoleArrays(shape) {\n  if (!shape) return [];\n  const holePrimitives = shape.shapePrimitives;\n  const holeArrays = [];\n  for (let k = 0; k < holePrimitives.length; k++) {\n    const holePrimitive = holePrimitives[k].shape;\n    const holePoints = [];\n    const holeBuilder = shapeBuilders[holePrimitive.type];\n    holeBuilder.build(holePrimitive, holePoints);\n    holeArrays.push(holePoints);\n  }\n  return holeArrays;\n}\nexport { buildContextBatches, shapeBuilders };","map":{"version":3,"names":["shapeBuilders","extensions","handleByMap","ExtensionType","ShapeBuilder","add","buildRectangle","buildPolygon","buildTriangle","buildCircle","buildEllipse","buildRoundedRectangle","tempRect","Rectangle","buildContextBatches","context","gpuContext","geometryData","batches","length","indices","vertices","uvs","i","instructions","instruction","action","addTextureToGeometryData","data","isStroke","shapePath","path","style","hole","addShapePathToGeometryData","indexOffset","vertOffset","points","build","rectangle","rect","texture","image","x","dx","y","dy","width","dw","height","dh","matrix","transform","transformVertices","triangulate","textureUvs","push","x0","y0","x1","y1","x3","y3","x2","y2","graphicsBatch","BigPool","get","BatchableGraphics","indexSize","attributeOffset","attributeSize","baseColor","alpha","lastIndex","shapePrimitives","forEach","_ref","shape","type","console","warn","holeIndices","otherPoints","slice","holeArrays","getHoleArrays","holePoints","triangulateWithHoles","close","closePath","lineStyle","buildLine","uvsOffset","Texture","WHITE","textureMatrix","append","clone","invert","buildUvs","buildSimpleUvs","color","holePrimitives","k","holePrimitive","holeBuilder"],"sources":["/workspaces/royal-games-updated/node_modules/pixi.js/src/scene/graphics/shared/utils/buildContextBatches.ts"],"sourcesContent":["import { extensions, ExtensionType } from '../../../../extensions/Extensions';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { buildSimpleUvs, buildUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { BigPool } from '../../../../utils/pool/PoolGroup';\nimport { BatchableGraphics } from '../BatchableGraphics';\nimport { buildCircle, buildEllipse, buildRoundedRectangle } from '../buildCommands/buildCircle';\nimport { buildLine } from '../buildCommands/buildLine';\nimport { buildPolygon } from '../buildCommands/buildPolygon';\nimport { buildRectangle } from '../buildCommands/buildRectangle';\nimport { buildTriangle } from '../buildCommands/buildTriangle';\nimport { triangulateWithHoles } from './triangulateWithHoles';\n\nimport type { Polygon } from '../../../../maths/shapes/Polygon';\nimport type { ShapeBuildCommand } from '../buildCommands/ShapeBuildCommand';\nimport type { ConvertedFillStyle, ConvertedStrokeStyle } from '../FillTypes';\nimport type { GraphicsContext, TextureInstruction } from '../GraphicsContext';\nimport type { GpuGraphicsContext } from '../GraphicsContextSystem';\nimport type { GraphicsPath } from '../path/GraphicsPath';\nimport type { ShapePath } from '../path/ShapePath';\n\nexport const shapeBuilders: Record<string, ShapeBuildCommand> = {};\n\nextensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);\nextensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);\n\nconst tempRect = new Rectangle();\n\nexport function buildContextBatches(context: GraphicsContext, gpuContext: GpuGraphicsContext)\n{\n    const { geometryData, batches } = gpuContext;\n\n    // reset them..\n    batches.length = 0;\n    geometryData.indices.length = 0;\n    geometryData.vertices.length = 0;\n    geometryData.uvs.length = 0;\n\n    for (let i = 0; i < context.instructions.length; i++)\n    {\n        const instruction = context.instructions[i];\n\n        if (instruction.action === 'texture')\n        {\n            // add a quad!\n            addTextureToGeometryData(instruction.data, batches, geometryData);\n        }\n        else if (instruction.action === 'fill' || instruction.action === 'stroke')\n        {\n            const isStroke = instruction.action === 'stroke';\n\n            // build path collection of polys and shapes points..\n            const shapePath = instruction.data.path.shapePath;\n\n            const style = instruction.data.style;\n\n            const hole = instruction.data.hole;\n\n            if (isStroke && hole)\n            {\n                addShapePathToGeometryData(hole.shapePath, style, null, true, batches, geometryData);\n            }\n\n            addShapePathToGeometryData(shapePath, style, hole, isStroke, batches, geometryData);\n        }\n    }\n}\n\nfunction addTextureToGeometryData(\n    data: TextureInstruction['data'],\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n\n    const indexOffset = indices.length;\n    const vertOffset = vertices.length / 2;\n\n    const points: number[] = [];\n\n    const build = shapeBuilders.rectangle;\n\n    const rect = tempRect;\n\n    const texture = data.image;\n\n    rect.x = data.dx;\n    rect.y = data.dy;\n    rect.width = data.dw;\n    rect.height = data.dh;\n\n    const matrix = data.transform;\n\n    // TODO - this can be cached...\n    build.build(rect, points);\n\n    if (matrix)\n    {\n        transformVertices(points, matrix);\n    }\n\n    build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n\n    const textureUvs = texture.uvs;\n\n    uvs.push(\n        textureUvs.x0, textureUvs.y0,\n        textureUvs.x1, textureUvs.y1,\n        textureUvs.x3, textureUvs.y3,\n        textureUvs.x2, textureUvs.y2,\n    );\n\n    const graphicsBatch = BigPool.get(BatchableGraphics);\n\n    graphicsBatch.indexOffset = indexOffset;\n    graphicsBatch.indexSize = indices.length - indexOffset;\n\n    graphicsBatch.attributeOffset = vertOffset;\n    graphicsBatch.attributeSize = (vertices.length / 2) - vertOffset;\n\n    graphicsBatch.baseColor = data.style;\n    graphicsBatch.alpha = data.alpha;\n\n    graphicsBatch.texture = texture;\n    graphicsBatch.geometryData = geometryData;\n\n    batches.push(graphicsBatch);\n}\n\nfunction addShapePathToGeometryData(\n    shapePath: ShapePath,\n    style: ConvertedFillStyle | ConvertedStrokeStyle,\n    hole: GraphicsPath,\n    isStroke: boolean,\n    batches: BatchableGraphics[],\n    geometryData: {\n        vertices: number[];\n        uvs: number[];\n        indices: number[];\n    }\n)\n{\n    const { vertices, uvs, indices } = geometryData;\n    const lastIndex = shapePath.shapePrimitives.length - 1;\n\n    shapePath.shapePrimitives.forEach(({ shape, transform: matrix }, i) =>\n    {\n        const indexOffset = indices.length;\n        const vertOffset = vertices.length / 2;\n\n        const points: number[] = [];\n\n        const build = shapeBuilders[shape.type];\n\n        // TODO - this can be cached...\n        // TODO - THIS IS DONE TWICE!!!!!!\n        // ONCE FOR STROKE AND ONCE FOR FILL\n        // move to the ShapePath2D class itself?\n        build.build(shape, points);\n\n        if (matrix)\n        {\n            transformVertices(points, matrix);\n        }\n\n        if (!isStroke)\n        {\n            if (hole && lastIndex === i)\n            {\n                if (lastIndex !== 0)\n                {\n                    console.warn('[Pixi Graphics] only the last shape have be cut out');\n                }\n\n                const holeIndices: number[] = [];\n\n                const otherPoints = points.slice();\n\n                const holeArrays = getHoleArrays(hole.shapePath);\n\n                holeArrays.forEach((holePoints) =>\n                {\n                    holeIndices.push(otherPoints.length / 2);\n                    otherPoints.push(...holePoints);\n                });\n\n                triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);\n            }\n            else\n            {\n                build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n            }\n        }\n        else\n        {\n            const close = (shape as Polygon).closePath ?? true;\n            const lineStyle = style as ConvertedStrokeStyle;\n\n            buildLine(points, lineStyle, false, close, vertices, 2, vertOffset, indices, indexOffset);\n        }\n\n        const uvsOffset = uvs.length / 2;\n\n        const texture = style.texture;\n\n        if (texture !== Texture.WHITE)\n        {\n            const textureMatrix = style.matrix;\n\n            if (textureMatrix)\n            {\n                // todo can prolly do this before calculating uvs..\n                if (matrix)\n                {\n                    textureMatrix.append(matrix.clone().invert());\n                }\n\n                buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset, textureMatrix);\n            }\n        }\n        else\n        {\n            buildSimpleUvs(uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset);\n        }\n\n        const graphicsBatch = BigPool.get(BatchableGraphics);\n\n        graphicsBatch.indexOffset = indexOffset;\n        graphicsBatch.indexSize = indices.length - indexOffset;\n\n        graphicsBatch.attributeOffset = vertOffset;\n        graphicsBatch.attributeSize = (vertices.length / 2) - vertOffset;\n\n        graphicsBatch.baseColor = style.color;\n        graphicsBatch.alpha = style.alpha;\n\n        graphicsBatch.texture = texture;\n        graphicsBatch.geometryData = geometryData;\n\n        batches.push(graphicsBatch);\n    });\n}\n\nfunction getHoleArrays(shape: ShapePath)\n{\n    if (!shape) return [];\n\n    const holePrimitives = shape.shapePrimitives;\n\n    const holeArrays = [];\n\n    for (let k = 0; k < holePrimitives.length; k++)\n    {\n        const holePrimitive = holePrimitives[k].shape;\n\n        // TODO - need to transform the points via there transform here..\n        const holePoints: number[] = [];\n\n        const holeBuilder = shapeBuilders[holePrimitive.type] as ShapeBuildCommand;\n\n        holeBuilder.build(holePrimitive, holePoints);\n\n        holeArrays.push(holePoints);\n    }\n\n    return holeArrays;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}